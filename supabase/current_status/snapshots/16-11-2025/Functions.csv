schema,function_name,arguments,definition
public,_next_occurrence,"p_date date, p_freq text, p_interval integer DEFAULT 1","CREATE OR REPLACE FUNCTION public._next_occurrence(p_date date, p_freq text, p_interval integer DEFAULT 1)
 RETURNS date
 LANGUAGE sql
 IMMUTABLE
 SET search_path TO ''
AS $function$
select case p_freq
  when 'weekly'  then p_date + (7 * p_interval)
  when 'monthly' then (p_date + (interval '1 month' * p_interval))::date
  when 'yearly'  then (p_date + (interval '1 year'  * p_interval))::date
  else p_date
end;
$function$
"
public,_pick_new_admin,p_event_id uuid,"CREATE OR REPLACE FUNCTION public._pick_new_admin(p_event_id uuid)
 RETURNS uuid
 LANGUAGE sql
 STABLE
 SET search_path TO ''
AS $function$
  select user_id
  from public.event_members
  where event_id = p_event_id
  order by created_at nulls last, user_id
  limit 1
$function$
"
public,_test_admin_for_event_title,p_title text,"CREATE OR REPLACE FUNCTION public._test_admin_for_event_title(p_title text)
 RETURNS uuid
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT em.user_id
  FROM public.event_members em
  JOIN public.events e ON e.id = em.event_id
  WHERE e.title = p_title AND em.role = 'admin'
  LIMIT 1
$function$
"
public,_test_any_member_for_event_title,p_title text,"CREATE OR REPLACE FUNCTION public._test_any_member_for_event_title(p_title text)
 RETURNS uuid
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT em.user_id
  FROM public.event_members em
  JOIN public.events e ON e.id = em.event_id
  WHERE e.title = p_title
  ORDER BY (em.role = 'admin') DESC
  LIMIT 1
$function$
"
public,_test_create_list_for_event,"p_event_id uuid, p_name text, p_vis list_visibility","CREATE OR REPLACE FUNCTION public._test_create_list_for_event(p_event_id uuid, p_name text, p_vis list_visibility)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- Call the specific overload by explicitly typing each placeholder.
  EXECUTE
    'SELECT public.create_list_with_people(
        $1::uuid,
        $2::text,
        $3::list_visibility,
        $4::uuid[],
        $5::uuid[]
      )'
  USING
    p_event_id,
    p_name,
    p_vis,
    ARRAY[]::uuid[],   -- recipients
    ARRAY[]::uuid[];   -- viewers
END
$function$
"
public,accept_claim_split,p_request_id uuid,"CREATE OR REPLACE FUNCTION public.accept_claim_split(p_request_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_request record;
BEGIN
  -- Validate user is authenticated
  IF auth.uid() IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  -- Get the request details
  SELECT * INTO v_request
  FROM public.claim_split_requests
  WHERE id = p_request_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Split request not found';
  END IF;

  -- Validate user is the original claimer
  IF v_request.original_claimer_id != auth.uid() THEN
    RAISE EXCEPTION 'Only the original claimer can accept this request';
  END IF;

  -- Validate request is still pending
  IF v_request.status != 'pending' THEN
    RAISE EXCEPTION 'Request has already been responded to';
  END IF;

  -- Validate requester hasn't already claimed the item
  IF EXISTS (
    SELECT 1 FROM public.claims
    WHERE item_id = v_request.item_id AND claimer_id = v_request.requester_id
  ) THEN
    RAISE EXCEPTION 'Requester has already claimed this item';
  END IF;

  -- Create a claim for the requester
  INSERT INTO public.claims (
    item_id,
    claimer_id,
    quantity,
    note
  ) VALUES (
    v_request.item_id,
    v_request.requester_id,
    1,
    'Split claim'
  );

  -- Update the request status
  UPDATE public.claim_split_requests
  SET
    status = 'accepted',
    responded_at = now()
  WHERE id = p_request_id;
END;
$function$
"
public,accept_event_invite,p_invite_id uuid,"CREATE OR REPLACE FUNCTION public.accept_event_invite(p_invite_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  v_invite record;
  v_user_id uuid;
BEGIN
  v_user_id := auth.uid();

  -- Get invite details including invited_role
  SELECT * INTO v_invite
  FROM public.event_invites
  WHERE id = p_invite_id
    AND invitee_id = v_user_id
    AND status = 'pending';

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Invite not found or already responded';
  END IF;

  -- Check if user can join (free tier limit check)
  IF NOT public.can_join_event(v_user_id) THEN
    RAISE EXCEPTION 'free_limit_reached'
      USING HINT = 'You can only be a member of 3 events on the free plan. Upgrade to join more events.';
  END IF;

  -- Add user to event with the role from the invite
  INSERT INTO public.event_members (event_id, user_id, role)
  VALUES (v_invite.event_id, v_user_id, COALESCE(v_invite.invited_role, 'giver'))
  ON CONFLICT DO NOTHING;

  -- Update invite status
  UPDATE public.event_invites
  SET status = 'accepted',
      responded_at = now()
  WHERE id = p_invite_id;
END;
$function$
"
public,add_list_recipient,"p_list_id uuid, p_recipient_email text","CREATE OR REPLACE FUNCTION public.add_list_recipient(p_list_id uuid, p_recipient_email text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  v_recipient_id uuid;
  v_event_id uuid;
  v_list_name text;
  v_creator_name text;
  v_event_title text;
  v_invite_id uuid;
  v_is_member boolean;
  v_list_creator uuid;
BEGIN
  -- Get list info and creator
  SELECT l.event_id, l.name, l.created_by, e.title
  INTO v_event_id, v_list_name, v_list_creator, v_event_title
  FROM public.lists l
  JOIN public.events e ON e.id = l.event_id
  WHERE l.id = p_list_id;

  IF v_event_id IS NULL THEN
    RAISE EXCEPTION 'List not found';
  END IF;

  -- Check authorization - must be list creator OR event member
  IF NOT (auth.uid() = v_list_creator OR EXISTS (
    SELECT 1 FROM public.event_members
    WHERE event_id = v_event_id AND user_id = auth.uid()
  )) THEN
    RAISE EXCEPTION 'Not authorized to modify this list. Caller: %, Creator: %', auth.uid(), v_list_creator;
  END IF;

  -- Normalize email
  p_recipient_email := lower(trim(p_recipient_email));

  -- Validate email format
  IF p_recipient_email !~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$' THEN
    RAISE EXCEPTION 'Invalid email format';
  END IF;

  -- Get creator name
  SELECT coalesce(display_name, 'Someone') INTO v_creator_name
  FROM public.profiles
  WHERE id = auth.uid();

  -- Check if email belongs to a registered user
  SELECT id INTO v_recipient_id
  FROM auth.users
  WHERE lower(email) = p_recipient_email;

  -- If registered user, check if they're already an event member
  IF v_recipient_id IS NOT NULL THEN
    SELECT EXISTS (
      SELECT 1 FROM public.event_members
      WHERE event_id = v_event_id
        AND user_id = v_recipient_id
    ) INTO v_is_member;
  ELSE
    v_is_member := false;
  END IF;

  -- Add recipient to list (check if already exists first)
  IF NOT EXISTS (
    SELECT 1 FROM public.list_recipients
    WHERE list_id = p_list_id
      AND (
        (user_id = v_recipient_id AND v_recipient_id IS NOT NULL)
        OR (lower(recipient_email) = p_recipient_email)
      )
  ) THEN
    -- If user is registered, use user_id only. Otherwise use email only.
    IF v_recipient_id IS NOT NULL THEN
      INSERT INTO public.list_recipients (list_id, user_id)
      VALUES (p_list_id, v_recipient_id);
    ELSE
      INSERT INTO public.list_recipients (list_id, recipient_email)
      VALUES (p_list_id, p_recipient_email);
    END IF;
  ELSE
    -- Update existing record if user_id changed (user signed up)
    UPDATE public.list_recipients
    SET user_id = v_recipient_id, recipient_email = NULL
    WHERE list_id = p_list_id
      AND lower(recipient_email) = p_recipient_email
      AND user_id IS NULL
      AND v_recipient_id IS NOT NULL;
  END IF;

  -- If user is not an event member, send invite
  IF NOT v_is_member THEN
    BEGIN
      -- Send event invite
      SELECT public.send_event_invite(v_event_id, p_recipient_email)
      INTO v_invite_id;

      -- If user is registered, also send a list notification
      IF v_recipient_id IS NOT NULL THEN
        INSERT INTO public.notification_queue (user_id, title, body, data)
        VALUES (
          v_recipient_id,
          'Gift List Created',
          v_creator_name || ' created a gift list for you in ' || v_event_title,
          jsonb_build_object(
            'type', 'list_for_recipient',
            'list_id', p_list_id,
            'event_id', v_event_id,
            'invite_id', v_invite_id
          )
        );
      END IF;
    EXCEPTION WHEN OTHERS THEN
      -- Log the error but don't fail the entire operation
      RAISE WARNING 'Failed to send invite/notification: % (SQLSTATE: %)', SQLERRM, SQLSTATE;
    END;
  END IF;

  RETURN v_recipient_id;
END;
$function$
"
public,allowed_event_slots,p_user uuid DEFAULT auth.uid(),"CREATE OR REPLACE FUNCTION public.allowed_event_slots(p_user uuid DEFAULT auth.uid())
 RETURNS integer
 LANGUAGE sql
 STABLE
 SET search_path TO ''
AS $function$
  select case when public.is_pro(p_user) then 1000000 else 3 end;
$function$
"
public,assign_items_randomly,p_list_id uuid,"CREATE OR REPLACE FUNCTION public.assign_items_randomly(p_list_id uuid)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user uuid;
  v_list record;
  v_is_admin boolean;
  v_available_members uuid[];
  v_unassigned_members uuid[];
  v_items uuid[];
  v_mode text;
  v_item_id uuid;
  v_member_id uuid;
  v_member_idx int;
  v_assignments_made int := 0;
BEGIN
  v_user := auth.uid();

  IF v_user IS NULL THEN
    RAISE EXCEPTION 'not_authenticated';
  END IF;

  -- Get list details
  SELECT l.*, l.random_assignment_mode, l.random_assignment_enabled, l.event_id, l.created_by
  INTO v_list
  FROM public.lists l
  WHERE l.id = p_list_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'list_not_found';
  END IF;

  IF NOT v_list.random_assignment_enabled THEN
    RAISE EXCEPTION 'random_assignment_not_enabled';
  END IF;

  -- Check if user is list owner or event admin
  SELECT
    (v_list.created_by = v_user) OR
    EXISTS(
      SELECT 1 FROM public.event_members em
      WHERE em.event_id = v_list.event_id
        AND em.user_id = v_user
        AND em.role = 'admin'
    ) OR
    EXISTS(
      SELECT 1 FROM public.events e
      WHERE e.id = v_list.event_id
        AND e.owner_id = v_user
    )
  INTO v_is_admin;

  IF NOT v_is_admin THEN
    RAISE EXCEPTION 'not_authorized';
  END IF;

  -- Get available members for assignment
  v_available_members := public.get_available_members_for_assignment(p_list_id);

  IF array_length(v_available_members, 1) IS NULL OR array_length(v_available_members, 1) = 0 THEN
    RAISE EXCEPTION 'no_available_members';
  END IF;

  v_mode := v_list.random_assignment_mode;

  -- Get unassigned items (items without any assignments)
  SELECT array_agg(i.id ORDER BY i.created_at)
  INTO v_items
  FROM public.items i
  WHERE i.list_id = p_list_id
    AND NOT EXISTS (
      SELECT 1 FROM public.claims c
      WHERE c.item_id = i.id
        AND c.assigned_to IS NOT NULL
    );

  IF array_length(v_items, 1) IS NULL OR array_length(v_items, 1) = 0 THEN
    -- No new items to assign
    UPDATE public.lists
    SET random_assignment_executed_at = now()
    WHERE id = p_list_id;

    RETURN json_build_object(
      'success', true,
      'assignments_made', 0,
      'member_count', array_length(v_available_members, 1),
      'message', 'no_new_items_to_assign'
    );
  END IF;

  -- All assignment operations are wrapped in implicit transaction
  -- If any INSERT fails, entire function rolls back

  -- Execute assignment based on mode
  IF v_mode = 'one_per_member' THEN
    -- Assign one item per member, prioritizing members with no assignments
    v_member_idx := 1;

    FOREACH v_item_id IN ARRAY v_items
    LOOP
      -- Get members who don't have any assignments yet
      SELECT array_agg(m.user_id ORDER BY random())
      INTO v_unassigned_members
      FROM (
        SELECT unnest(v_available_members) AS user_id
      ) m
      WHERE NOT EXISTS (
        SELECT 1 FROM public.claims c
        JOIN public.items i ON i.id = c.item_id
        WHERE c.assigned_to = m.user_id
          AND i.list_id = p_list_id
      );

      -- Exit if all members have at least one assignment
      EXIT WHEN array_length(v_unassigned_members, 1) IS NULL OR array_length(v_unassigned_members, 1) = 0;

      -- Assign to first member in shuffled array
      v_member_id := v_unassigned_members[1];

      -- Create assignment (claim with assigned_to)
      -- Use INSERT ... ON CONFLICT to ensure idempotency
      INSERT INTO public.claims (item_id, claimer_id, assigned_to)
      VALUES (v_item_id, v_member_id, v_member_id)
      ON CONFLICT (item_id, claimer_id) DO UPDATE
      SET assigned_to = EXCLUDED.assigned_to;

      v_assignments_made := v_assignments_made + 1;
    END LOOP;

  ELSIF v_mode = 'distribute_all' THEN
    -- Distribute all items as evenly as possible
    v_member_idx := 1;

    FOREACH v_item_id IN ARRAY v_items
    LOOP
      -- Get member with fewest assignments for this list
      SELECT m.user_id INTO v_member_id
      FROM (SELECT unnest(v_available_members) AS user_id) m
      LEFT JOIN (
        SELECT c.assigned_to, COUNT(*) as assignment_count
        FROM public.claims c
        JOIN public.items i ON i.id = c.item_id
        WHERE i.list_id = p_list_id
          AND c.assigned_to IS NOT NULL
        GROUP BY c.assigned_to
      ) counts ON counts.assigned_to = m.user_id
      ORDER BY COALESCE(counts.assignment_count, 0), random()
      LIMIT 1;

      IF v_member_id IS NULL THEN
        EXIT;
      END IF;

      -- Create assignment with idempotency
      INSERT INTO public.claims (item_id, claimer_id, assigned_to)
      VALUES (v_item_id, v_member_id, v_member_id)
      ON CONFLICT (item_id, claimer_id) DO UPDATE
      SET assigned_to = EXCLUDED.assigned_to;

      v_assignments_made := v_assignments_made + 1;
    END LOOP;

  ELSE
    RAISE EXCEPTION 'invalid_assignment_mode';
  END IF;

  -- Update execution timestamp
  UPDATE public.lists
  SET random_assignment_executed_at = now()
  WHERE id = p_list_id;

  RETURN json_build_object(
    'success', true,
    'assignments_made', v_assignments_made,
    'member_count', array_length(v_available_members, 1),
    'mode', v_mode
  );

EXCEPTION
  WHEN OTHERS THEN
    -- Log error and re-raise to trigger rollback
    RAISE WARNING 'assign_items_randomly failed for list %: % %', p_list_id, SQLERRM, SQLSTATE;
    RAISE;
END;
$function$
"
public,autojoin_event_as_admin,,"CREATE OR REPLACE FUNCTION public.autojoin_event_as_admin()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
begin
  insert into public.event_members(event_id, user_id, role)
  values (new.id, new.owner_id, 'admin')
  on conflict do nothing;
  return new;
end;
$function$
"
public,backfill_event_member_stats,,"CREATE OR REPLACE FUNCTION public.backfill_event_member_stats()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- For each event member, calculate their stats
  -- Include collaborative mode claims (where user is both giver and recipient)

  INSERT INTO event_member_stats (event_id, user_id, total_claims, unpurchased_claims)
  SELECT
    em.event_id,
    em.user_id,
    COALESCE(COUNT(c.id), 0) as total_claims,
    COALESCE(COUNT(c.id) FILTER (WHERE c.purchased = false), 0) as unpurchased_claims
  FROM event_members em
  LEFT JOIN lists l ON l.event_id = em.event_id
  LEFT JOIN items i ON i.list_id = l.id
  LEFT JOIN claims c ON c.item_id = i.id AND c.claimer_id = em.user_id
  LEFT JOIN list_recipients lr ON lr.list_id = l.id AND lr.user_id = em.user_id
  WHERE
    -- Include claims in collaborative mode
    (
      COALESCE(l.random_assignment_enabled, false) = true
      AND COALESCE(l.random_receiver_assignment_enabled, false) = true
    )
    -- OR include claims where user is NOT a recipient
    OR lr.list_id IS NULL
  GROUP BY em.event_id, em.user_id
  ON CONFLICT (event_id, user_id) DO UPDATE SET
    total_claims = EXCLUDED.total_claims,
    unpurchased_claims = EXCLUDED.unpurchased_claims,
    updated_at = now();
END;
$function$
"
public,can_claim_item,"p_item_id uuid, p_user uuid","CREATE OR REPLACE FUNCTION public.can_claim_item(p_item_id uuid, p_user uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE
 SET search_path TO 'public'
AS $function$
  WITH i AS (
    SELECT i.id, i.list_id, l.event_id, l.random_assignment_enabled, l.created_by
    FROM public.items i
    JOIN public.lists l ON l.id = i.list_id
    WHERE i.id = p_item_id
  ),

  is_admin AS (
    SELECT EXISTS (
      SELECT 1
      FROM i
      LEFT JOIN public.event_members em ON em.event_id = i.event_id AND em.user_id = p_user
      LEFT JOIN public.events e ON e.id = i.event_id
      WHERE i.created_by = p_user
         OR em.role = 'admin'
         OR e.owner_id = p_user
    ) AS admin_check
  ),

  is_assigned AS (
    SELECT EXISTS (
      SELECT 1
      FROM public.claims c
      WHERE c.item_id = p_item_id
        AND c.assigned_to = p_user
    ) AS assigned_check
  )

  SELECT
    -- Must be event member
    EXISTS (
      SELECT 1 FROM i
      JOIN public.event_members em
        ON em.event_id = i.event_id AND em.user_id = p_user
    )
    -- Must not be a recipient of the list
    AND NOT EXISTS (
      SELECT 1 FROM public.list_recipients lr
      JOIN i ON i.list_id = lr.list_id
      WHERE lr.user_id = p_user
    )
    -- If random assignment enabled, must be assigned to user OR user is admin
    AND (
      NOT (SELECT random_assignment_enabled FROM i)
      OR (SELECT admin_check FROM is_admin)
      OR (SELECT assigned_check FROM is_assigned)
    )
$function$
"
public,can_create_event,p_user uuid,"CREATE OR REPLACE FUNCTION public.can_create_event(p_user uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  select case
    when public.is_pro(p_user, now()) then true
    -- Count TOTAL event memberships (owned + joined)
    else (select count(*) < 3 from public.event_members where user_id = p_user)
  end;
$function$
"
public,can_join_event,p_user uuid,"CREATE OR REPLACE FUNCTION public.can_join_event(p_user uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  select case
    when public.is_pro(p_user, now()) then true
    -- Count TOTAL event memberships (owned + joined)
    else (select count(*) < 3 from public.event_members where user_id = p_user)
  end;
$function$
"
public,can_view_list,p_list uuid,"CREATE OR REPLACE FUNCTION public.can_view_list(p_list uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT public.is_member_of_event(l.event_id)
     AND NOT EXISTS (
           SELECT 1
           FROM public.list_exclusions e
           WHERE e.list_id = p_list
             AND e.user_id = auth.uid()
         )
  FROM public.lists l
  WHERE l.id = p_list;
$function$
"
public,can_view_list,"uuid, uuid","CREATE OR REPLACE FUNCTION public.can_view_list(uuid, uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  with l as (
    select event_id, visibility, created_by
    from public.lists
    where id = $1
  ),
  excluded as (
    select exists(
      select 1 from public.list_exclusions
      where list_id = $1 and user_id = $2
    ) as x
  )
  select
    exists(select 1 from l)
    and not (select x from excluded)
    and (
      exists(select 1 from l where created_by = $2)
      or
      exists(select 1 from public.list_recipients lr
             where lr.list_id = $1 and lr.user_id = $2)
      or
      exists(select 1 from l where visibility = 'event'
             and exists (select 1 from public.event_members em
                         where em.event_id = l.event_id and em.user_id = $2))
      or
      exists(select 1 from l where visibility = 'selected'
             and exists (select 1 from public.list_viewers v
                         where v.list_id = $1 and v.user_id = $2))
    );
  $function$
"
public,check_and_queue_purchase_reminders,,"CREATE OR REPLACE FUNCTION public.check_and_queue_purchase_reminders()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  v_user record;
  v_event record;
  v_event_date date;
  v_days_until int;
  v_claimed_count int;
  v_total_count int;
  v_title text;
  v_body text;
begin
  -- Loop through users who have reminder_days set AND are pro
  for v_user in
    select p.id, p.reminder_days
    from public.profiles p
    where p.reminder_days is not null
      and p.reminder_days > 0
      -- NEW: Only process pro users
      and public.is_pro(p.id, now()) = true
      -- Only process if they have push tokens
      and exists (
        select 1 from public.push_tokens pt where pt.user_id = p.id
      )
  loop
    -- For each user, check their events
    for v_event in
      select distinct e.id, e.title, e.event_date
      from public.events e
      join public.event_members em on em.event_id = e.id
      where em.user_id = v_user.id
        and e.event_date is not null
        and e.event_date >= current_date
    loop
      v_event_date := v_event.event_date;
      v_days_until := v_event_date - current_date;

      -- Check if we should send reminder for this event
      if v_days_until = v_user.reminder_days then
        -- Count user's claimed items for this event
        select count(distinct c.id)
        into v_claimed_count
        from public.claims c
        join public.items i on i.id = c.item_id
        join public.lists l on l.id = i.list_id
        where l.event_id = v_event.id
          and c.claimer_id = v_user.id
          and c.purchased = false;

        -- Only send if they have unpurchased claims
        if v_claimed_count > 0 then
          -- Build notification
          v_title := 'Purchase Reminder: ' || v_event.title;
          if v_claimed_count = 1 then
            v_body := 'You have 1 unpurchased item for ' || v_event.title || ' in ' || v_days_until || ' days.';
          else
            v_body := 'You have ' || v_claimed_count || ' unpurchased items for ' || v_event.title || ' in ' || v_days_until || ' days.';
          end if;

          -- Queue notification
          insert into public.notification_queue (user_id, title, body, data)
          values (
            v_user.id,
            v_title,
            v_body,
            jsonb_build_object(
              'type', 'purchase_reminder',
              'event_id', v_event.id,
              'event_title', v_event.title,
              'days_until', v_days_until,
              'unpurchased_count', v_claimed_count
            )
          );
        end if;
      end if;
    end loop;
  end loop;
end;
$function$
"
public,check_rate_limit,"p_action text, p_max_requests integer DEFAULT 100, p_window_seconds integer DEFAULT 60","CREATE OR REPLACE FUNCTION public.check_rate_limit(p_action text, p_max_requests integer DEFAULT 100, p_window_seconds integer DEFAULT 60)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_id uuid;
  v_window_start timestamptz;
  v_current_count int;
BEGIN
  v_user_id := auth.uid();

  IF v_user_id IS NULL THEN
    -- Anonymous users get stricter limits
    p_max_requests := LEAST(p_max_requests, 10);
  END IF;

  -- Calculate current window start (floor to window boundary)
  v_window_start := date_trunc('minute', now()) -
    ((EXTRACT(EPOCH FROM date_trunc('minute', now()))::int % p_window_seconds) * interval '1 second');

  -- Get or create rate limit record
  INSERT INTO public.rate_limit_tracking (user_id, action, window_start, request_count)
  VALUES (COALESCE(v_user_id, '00000000-0000-0000-0000-000000000000'::uuid), p_action, v_window_start, 1)
  ON CONFLICT (user_id, action, window_start)
  DO UPDATE SET request_count = rate_limit_tracking.request_count + 1
  RETURNING request_count INTO v_current_count;

  -- Check if limit exceeded
  IF v_current_count > p_max_requests THEN
    PERFORM log_security_event(
      'rate_limit_exceeded',
      'rate_limit',
      NULL,
      false,
      format('User exceeded rate limit for action: %s', p_action),
      jsonb_build_object('action', p_action, 'count', v_current_count, 'limit', p_max_requests)
    );
    RETURN false;
  END IF;

  RETURN true;
END;
$function$
"
public,claim_counts_for_lists,p_list_ids uuid[],"CREATE OR REPLACE FUNCTION public.claim_counts_for_lists(p_list_ids uuid[])
 RETURNS TABLE(list_id uuid, claim_count integer)
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  with items_by_list as (
    select i.id as item_id, i.list_id
    from public.items i
    where i.list_id = any(p_list_ids)
  )
  select ibl.list_id, count(c.id)::int as claim_count
  from items_by_list ibl
  left join public.claims c on c.item_id = ibl.item_id
  join public.lists l on l.id = ibl.list_id
  where public.can_view_list(l.id, auth.uid())
  group by ibl.list_id
$function$
"
public,claim_item,p_item_id uuid,"CREATE OR REPLACE FUNCTION public.claim_item(p_item_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  u uuid := auth.uid();
begin
  if u is null then
    raise exception 'not_authenticated';
  end if;

  if not can_claim_item(p_item_id, u) then
    raise exception 'not_authorized';
  end if;

  insert into public.claims(item_id, claimer_id)
  values (p_item_id, u)
  on conflict (item_id, claimer_id) do nothing;
end;
$function$
"
public,cleanup_old_activity_logs,,"CREATE OR REPLACE FUNCTION public.cleanup_old_activity_logs()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  delete from public.daily_activity_log
  where created_at < now() - interval '7 days';
end;
$function$
"
public,cleanup_old_invites,,"CREATE OR REPLACE FUNCTION public.cleanup_old_invites()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
begin
  delete from public.event_invites
  where status in ('accepted', 'declined')
    and responded_at < now() - interval '30 days';
end;
$function$
"
public,cleanup_old_notifications,,"CREATE OR REPLACE FUNCTION public.cleanup_old_notifications()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
begin
  delete from public.notification_queue
  where sent = true
    and created_at < now() - interval '7 days';
end;
$function$
"
public,cleanup_old_reminders,,"CREATE OR REPLACE FUNCTION public.cleanup_old_reminders()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
begin
  delete from public.sent_reminders sr
  using public.events e
  where sr.event_id = e.id
    and (e.event_date < now() - interval '7 days' or e.event_date is null);
end;
$function$
"
public,cleanup_orphaned_lists,,"CREATE OR REPLACE FUNCTION public.cleanup_orphaned_lists()
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_deleted_count INTEGER := 0;
  v_orphaned RECORD;
BEGIN
  -- Find all orphaned lists ready for deletion
  FOR v_orphaned IN
    SELECT ol.id, ol.list_id, ol.event_id, ol.excluded_user_id
    FROM public.orphaned_lists ol
    WHERE ol.delete_at <= NOW()
  LOOP
    -- Verify the user is still the sole member before deleting
    IF is_sole_event_member(v_orphaned.event_id, v_orphaned.excluded_user_id) THEN
      -- Verify the user is still excluded from this list
      IF EXISTS(
        SELECT 1 FROM public.list_exclusions
        WHERE list_id = v_orphaned.list_id
          AND user_id = v_orphaned.excluded_user_id
      ) THEN
        -- Delete the list (cascade will handle items, claims, etc.)
        DELETE FROM public.lists WHERE id = v_orphaned.list_id;
        v_deleted_count := v_deleted_count + 1;
      END IF;
    END IF;

    -- Remove from orphaned_lists tracking table
    DELETE FROM public.orphaned_lists WHERE id = v_orphaned.id;
  END LOOP;

  RETURN v_deleted_count;
END;
$function$
"
public,cleanup_rate_limit_tracking,,"CREATE OR REPLACE FUNCTION public.cleanup_rate_limit_tracking()
 RETURNS void
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  DELETE FROM public.rate_limit_tracking
  WHERE window_start < (now() - interval '1 hour');
$function$
"
public,cleanup_reminder_on_purchase,,"CREATE OR REPLACE FUNCTION public.cleanup_reminder_on_purchase()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
begin
  -- If item was marked as purchased, remove any pending reminders
  if NEW.purchased = true and OLD.purchased = false then
    delete from public.sent_reminders
    where claim_id = NEW.id;
  end if;

  return NEW;
end;
$function$
"
public,create_event_and_admin,"p_title text, p_event_date date, p_recurrence text, p_description text, p_admin_only_invites boolean DEFAULT false, p_admin_emails text[] DEFAULT ARRAY[]::text[]","CREATE OR REPLACE FUNCTION public.create_event_and_admin(p_title text, p_event_date date, p_recurrence text, p_description text, p_admin_only_invites boolean DEFAULT false, p_admin_emails text[] DEFAULT ARRAY[]::text[])
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_user uuid := auth.uid();
  v_event_id uuid;
  v_admin_email text;
  v_invitee_id uuid;
  v_user_email text;
begin
  -- Authentication check
  if v_user is null then
    raise exception 'not_authenticated';
  end if;

  -- Validate title (not empty after trimming)
  if trim(coalesce(p_title, '')) = '' then
    raise exception 'invalid_parameter: title_required';
  end if;

  -- Validate recurrence value
  if p_recurrence not in ('none', 'weekly', 'monthly', 'yearly') then
    raise exception 'invalid_parameter: invalid_recurrence';
  end if;

  -- Validate event_date (must be in the future or today)
  if p_event_date < current_date then
    raise exception 'invalid_parameter: event_date_must_be_future';
  end if;

  -- Check free tier limits
  if not public.can_create_event(v_user) then
    raise exception 'free_limit_reached';
  end if;

  -- Get creator's email for inviter_id
  select email into v_user_email
  from auth.users
  where id = v_user;

  -- Create event with admin_only_invites setting
  insert into public.events (title, description, event_date, owner_id, recurrence, admin_only_invites)
  values (trim(p_title), p_description, p_event_date, v_user, coalesce(p_recurrence, 'none'), coalesce(p_admin_only_invites, false))
  returning id into v_event_id;

  -- Make creator an admin member
  insert into public.event_members (event_id, user_id, role)
  values (v_event_id, v_user, 'admin')
  on conflict do nothing;

  -- Invite additional admins if provided
  if array_length(p_admin_emails, 1) > 0 then
    foreach v_admin_email in array p_admin_emails
    loop
      -- Normalize email
      v_admin_email := lower(trim(v_admin_email));

      -- Skip if empty or invalid
      if v_admin_email = '' or v_admin_email !~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$' then
        continue;
      end if;

      -- Skip if it's the creator's email
      if v_admin_email = lower(v_user_email) then
        continue;
      end if;

      -- Check if user exists
      select id into v_invitee_id
      from auth.users
      where lower(email) = v_admin_email;

      -- Create invite with admin role
      insert into public.event_invites (event_id, inviter_id, invitee_email, invitee_id, invited_role)
      values (v_event_id, v_user, v_admin_email, v_invitee_id, 'admin')
      on conflict (event_id, invitee_email) do update
        set invited_role = 'admin',
            inviter_id = v_user,
            invitee_id = excluded.invitee_id,
            status = 'pending',
            invited_at = now(),
            responded_at = null;

      -- Note: Email sending will be handled by existing edge functions/triggers
    end loop;
  end if;

  return v_event_id;
end;
$function$
"
public,create_event_and_admin,"p_title text, p_event_date date, p_recurrence text, p_description text, p_admin_only_invites boolean DEFAULT false","CREATE OR REPLACE FUNCTION public.create_event_and_admin(p_title text, p_event_date date, p_recurrence text, p_description text, p_admin_only_invites boolean DEFAULT false)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_user uuid := auth.uid();
  v_event_id uuid;
begin
  -- Authentication check
  if v_user is null then
    raise exception 'not_authenticated';
  end if;

  -- Validate title (not empty after trimming)
  if trim(coalesce(p_title, '')) = '' then
    raise exception 'invalid_parameter: title_required';
  end if;

  -- Validate recurrence value
  if p_recurrence not in ('none', 'weekly', 'monthly', 'yearly') then
    raise exception 'invalid_parameter: invalid_recurrence';
  end if;

  -- Validate event_date (must be in the future or today)
  if p_event_date < current_date then
    raise exception 'invalid_parameter: event_date_must_be_future';
  end if;

  -- Check free tier limits
  if not public.can_create_event(v_user) then
    raise exception 'free_limit_reached';
  end if;

  -- Create event with admin_only_invites setting
  insert into public.events (title, description, event_date, owner_id, recurrence, admin_only_invites)
  values (trim(p_title), p_description, p_event_date, v_user, coalesce(p_recurrence, 'none'), coalesce(p_admin_only_invites, false))
  returning id into v_event_id;

  -- Make creator an admin member
  insert into public.event_members (event_id, user_id, role)
  values (v_event_id, v_user, 'admin')
  on conflict do nothing;

  return v_event_id;
end;
$function$
"
public,create_event_and_admin,"p_title text, p_event_date date, p_recurrence text, p_description text","CREATE OR REPLACE FUNCTION public.create_event_and_admin(p_title text, p_event_date date, p_recurrence text, p_description text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_user uuid := auth.uid();
  v_event_id uuid;
begin
  -- Authentication check
  if v_user is null then
    raise exception 'not_authenticated';
  end if;

  -- Validate title (not empty after trimming)
  if trim(coalesce(p_title, '')) = '' then
    raise exception 'invalid_parameter: title_required';
  end if;

  -- Validate recurrence value
  if p_recurrence not in ('none', 'weekly', 'monthly', 'yearly') then
    raise exception 'invalid_parameter: invalid_recurrence';
  end if;

  -- Validate event_date (must be in the future or today)
  if p_event_date < current_date then
    raise exception 'invalid_parameter: event_date_must_be_future';
  end if;

  -- Check free tier limits
  if not public.can_create_event(v_user) then
    raise exception 'free_limit_reached';
  end if;

  -- Create event
  insert into public.events (title, description, event_date, owner_id, recurrence)
  values (trim(p_title), p_description, p_event_date, v_user, coalesce(p_recurrence, 'none'))
  returning id into v_event_id;

  -- Make creator an admin member
  insert into public.event_members (event_id, user_id, role)
  values (v_event_id, v_user, 'admin')
  on conflict do nothing;

  return v_event_id;
end;
$function$
"
public,create_list_with_people,"p_event_id uuid, p_name text, p_visibility list_visibility DEFAULT 'event'::list_visibility, p_recipients uuid[] DEFAULT '{}'::uuid[], p_viewers uuid[] DEFAULT '{}'::uuid[]","CREATE OR REPLACE FUNCTION public.create_list_with_people(p_event_id uuid, p_name text, p_visibility list_visibility DEFAULT 'event'::list_visibility, p_recipients uuid[] DEFAULT '{}'::uuid[], p_viewers uuid[] DEFAULT '{}'::uuid[])
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare
  v_user    uuid := auth.uid();
  v_list_id uuid;
begin
  -- Authentication check
  if v_user is null then
    raise exception 'not_authenticated';
  end if;

  -- Validate list name (not empty after trimming)
  if trim(coalesce(p_name, '')) = '' then
    raise exception 'invalid_parameter: name_required';
  end if;

  -- Validate event_id exists and user is a member
  if not public.is_event_member(p_event_id, v_user) then
    raise exception 'not_authorized: must_be_event_member';
  end if;

  -- Validate visibility value
  if p_visibility not in ('event', 'selected', 'public') then
    raise exception 'invalid_parameter: invalid_visibility';
  end if;

  -- Create list
  insert into public.lists (event_id, name, created_by, visibility)
  values (p_event_id, trim(p_name), v_user, coalesce(p_visibility, 'event'))
  returning id into v_list_id;

  -- Add recipients
  if array_length(p_recipients, 1) is not null then
    insert into public.list_recipients (list_id, user_id)
    select v_list_id, unnest(p_recipients);
  end if;

  -- Add viewers for 'selected' visibility
  if coalesce(p_visibility, 'event') = 'selected' and array_length(p_viewers, 1) is not null then
    insert into public.list_viewers (list_id, user_id)
    select v_list_id, unnest(p_viewers);
  end if;

  return v_list_id;
end;
$function$
"
public,create_list_with_people,"p_event_id uuid, p_name text, p_visibility list_visibility DEFAULT 'event'::list_visibility, p_recipients uuid[] DEFAULT '{}'::uuid[], p_hidden_recipients uuid[] DEFAULT '{}'::uuid[], p_viewers uuid[] DEFAULT '{}'::uuid[], p_custom_recipient_name text DEFAULT NULL::text, p_random_assignment_enabled boolean DEFAULT false, p_random_assignment_mode text DEFAULT NULL::text","CREATE OR REPLACE FUNCTION public.create_list_with_people(p_event_id uuid, p_name text, p_visibility list_visibility DEFAULT 'event'::list_visibility, p_recipients uuid[] DEFAULT '{}'::uuid[], p_hidden_recipients uuid[] DEFAULT '{}'::uuid[], p_viewers uuid[] DEFAULT '{}'::uuid[], p_custom_recipient_name text DEFAULT NULL::text, p_random_assignment_enabled boolean DEFAULT false, p_random_assignment_mode text DEFAULT NULL::text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  v_user uuid;
  v_list_id uuid;
  v_is_member boolean;
BEGIN
  v_user := auth.uid();

  IF v_user IS NULL THEN
    RAISE EXCEPTION 'not_authenticated';
  END IF;

  -- Check membership in event
  SELECT EXISTS(
    SELECT 1 FROM public.event_members
    WHERE event_id = p_event_id AND user_id = v_user
  ) INTO v_is_member;

  IF NOT v_is_member THEN
    RAISE EXCEPTION 'not_an_event_member';
  END IF;

  -- Validate random assignment mode if enabled
  IF p_random_assignment_enabled THEN
    IF p_random_assignment_mode IS NULL OR
       p_random_assignment_mode NOT IN ('one_per_member', 'distribute_all') THEN
      RAISE EXCEPTION 'invalid_random_assignment_mode';
    END IF;
  END IF;

  -- Create list with all fields including random assignment settings
  INSERT INTO public.lists (
    event_id,
    name,
    created_by,
    visibility,
    custom_recipient_name,
    random_assignment_enabled,
    random_assignment_mode
  )
  VALUES (
    p_event_id,
    trim(p_name),
    v_user,
    COALESCE(p_visibility, 'event'),
    p_custom_recipient_name,
    p_random_assignment_enabled,
    CASE WHEN p_random_assignment_enabled THEN p_random_assignment_mode ELSE NULL END
  )
  RETURNING id INTO v_list_id;

  -- Add recipients (per-recipient can_view flag)
  IF array_length(p_recipients, 1) IS NOT NULL THEN
    INSERT INTO public.list_recipients (list_id, user_id, can_view)
    SELECT v_list_id, r, NOT (r = ANY(COALESCE(p_hidden_recipients, '{}')))
    FROM unnest(p_recipients) AS r;
  END IF;

  -- Add explicit viewers (only matters when visibility = 'selected')
  IF COALESCE(p_visibility, 'event') = 'selected'
     AND array_length(p_viewers, 1) IS NOT NULL THEN
    INSERT INTO public.list_viewers (list_id, user_id)
    SELECT v_list_id, v
    FROM unnest(p_viewers) AS v;
  END IF;

  RETURN v_list_id;
END;
$function$
"
public,create_list_with_people,"p_event_id uuid, p_name text, p_visibility list_visibility DEFAULT 'event'::list_visibility, p_recipients uuid[] DEFAULT '{}'::uuid[]","CREATE OR REPLACE FUNCTION public.create_list_with_people(p_event_id uuid, p_name text, p_visibility list_visibility DEFAULT 'event'::list_visibility, p_recipients uuid[] DEFAULT '{}'::uuid[])
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare
  v_user    uuid := auth.uid();
  v_list_id uuid;
begin
  if v_user is null then
    raise exception 'not authenticated';
  end if;

  if not public.is_event_member(p_event_id, v_user) then
    raise exception 'not_an_event_member';
  end if;

  insert into public.lists (event_id, name, created_by, visibility)
  values (p_event_id, trim(p_name), v_user, coalesce(p_visibility, 'event'))
  returning id into v_list_id;

  if array_length(p_recipients, 1) is not null then
    insert into public.list_recipients (list_id, user_id)
    select v_list_id, unnest(p_recipients);
  end if;

  return v_list_id;
end;
$function$
"
public,create_list_with_people,"p_event_id uuid, p_name text, p_visibility text, p_custom_recipient_name text, p_recipient_user_ids uuid[], p_recipient_emails text[], p_viewer_ids uuid[], p_exclusion_ids uuid[]","CREATE OR REPLACE FUNCTION public.create_list_with_people(p_event_id uuid, p_name text, p_visibility text, p_custom_recipient_name text, p_recipient_user_ids uuid[], p_recipient_emails text[], p_viewer_ids uuid[], p_exclusion_ids uuid[])
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare
  v_list_id uuid;
  v_recipient_id uuid;
  v_recipient_email text;
begin
  -- Validate inputs
  if p_name is null or trim(p_name) = '' then
    raise exception 'List name cannot be empty' using errcode = 'invalid_parameter';
  end if;

  if p_visibility not in ('private', 'shared', 'public') then
    raise exception 'Invalid visibility value' using errcode = 'invalid_parameter';
  end if;

  -- Validate user is member of event
  if not exists (
    select 1 from public.event_members
    where event_id = p_event_id and user_id = auth.uid()
  ) then
    raise exception 'Not authorized' using errcode = 'insufficient_privilege';
  end if;

  -- Create list
  insert into public.lists (event_id, name, visibility, custom_recipient_name, created_by)
  values (p_event_id, p_name, p_visibility::visibility_level, p_custom_recipient_name, auth.uid())
  returning id into v_list_id;

  -- Add user ID recipients
  if p_recipient_user_ids is not null then
    foreach v_recipient_id in array p_recipient_user_ids loop
      if not exists (
        select 1 from public.list_recipients
        where list_id = v_list_id and user_id = v_recipient_id
      ) then
        insert into public.list_recipients (list_id, user_id)
        values (v_list_id, v_recipient_id);
      end if;
    end loop;
  end if;

  -- Add email recipients (auto-invites non-members)
  if p_recipient_emails is not null then
    foreach v_recipient_email in array p_recipient_emails loop
      perform public.add_list_recipient(v_list_id, v_recipient_email);
    end loop;
  end if;

  -- Add viewers
  if p_viewer_ids is not null then
    insert into public.list_viewers (list_id, user_id)
    select v_list_id, unnest(p_viewer_ids)
    on conflict do nothing;
  end if;

  -- Add exclusions
  if p_exclusion_ids is not null then
    insert into public.list_exclusions (list_id, user_id)
    select v_list_id, unnest(p_exclusion_ids)
    on conflict do nothing;
  end if;

  return v_list_id;
end;
$function$
"
public,create_list_with_people,"p_event_id uuid, p_name text, p_visibility list_visibility DEFAULT 'event'::list_visibility, p_recipients uuid[] DEFAULT '{}'::uuid[], p_hidden_recipients uuid[] DEFAULT '{}'::uuid[], p_viewers uuid[] DEFAULT '{}'::uuid[], p_custom_recipient_name text DEFAULT NULL::text","CREATE OR REPLACE FUNCTION public.create_list_with_people(p_event_id uuid, p_name text, p_visibility list_visibility DEFAULT 'event'::list_visibility, p_recipients uuid[] DEFAULT '{}'::uuid[], p_hidden_recipients uuid[] DEFAULT '{}'::uuid[], p_viewers uuid[] DEFAULT '{}'::uuid[], p_custom_recipient_name text DEFAULT NULL::text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare
  v_user uuid;
  v_list_id uuid;
  v_is_member boolean;
begin
  v_user := auth.uid();
  if v_user is null then
    raise exception 'not_authenticated';
  end if;

  -- Check membership in event
  select exists(
    select 1 from public.event_members
    where event_id = p_event_id and user_id = v_user
  ) into v_is_member;

  if not v_is_member then
    raise exception 'not_an_event_member';
  end if;

  -- Create list with custom recipient name if provided
  insert into public.lists (event_id, name, created_by, visibility, custom_recipient_name)
  values (p_event_id, trim(p_name), v_user, coalesce(p_visibility, 'event'), p_custom_recipient_name)
  returning id into v_list_id;

  -- recipients (per-recipient can_view flag)
  if array_length(p_recipients, 1) is not null then
    insert into public.list_recipients (list_id, user_id, can_view)
    select v_list_id, r, not (r = any(coalesce(p_hidden_recipients, '{}')))
    from unnest(p_recipients) as r;
  end if;

  -- explicit viewers (only matters when visibility = 'selected')
  if coalesce(p_visibility, 'event') = 'selected'
     and array_length(p_viewers, 1) is not null then
    insert into public.list_viewers (list_id, user_id)
    select v_list_id, v
    from unnest(p_viewers) as v;
  end if;

  return v_list_id;
end;
$function$
"
public,create_list_with_people,"p_event_id uuid, p_name text, p_visibility list_visibility DEFAULT 'event'::list_visibility, p_recipients uuid[] DEFAULT '{}'::uuid[], p_hidden_recipients uuid[] DEFAULT '{}'::uuid[], p_viewers uuid[] DEFAULT '{}'::uuid[], p_custom_recipient_name text DEFAULT NULL::text, p_random_assignment_enabled boolean DEFAULT false, p_random_assignment_mode text DEFAULT NULL::text, p_random_receiver_assignment_enabled boolean DEFAULT false, p_for_everyone boolean DEFAULT false","CREATE OR REPLACE FUNCTION public.create_list_with_people(p_event_id uuid, p_name text, p_visibility list_visibility DEFAULT 'event'::list_visibility, p_recipients uuid[] DEFAULT '{}'::uuid[], p_hidden_recipients uuid[] DEFAULT '{}'::uuid[], p_viewers uuid[] DEFAULT '{}'::uuid[], p_custom_recipient_name text DEFAULT NULL::text, p_random_assignment_enabled boolean DEFAULT false, p_random_assignment_mode text DEFAULT NULL::text, p_random_receiver_assignment_enabled boolean DEFAULT false, p_for_everyone boolean DEFAULT false)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  v_user uuid;
  v_list_id uuid;
  v_is_member boolean;
BEGIN
  v_user := auth.uid();

  IF v_user IS NULL THEN
    RAISE EXCEPTION 'not_authenticated';
  END IF;

  -- Check membership in event
  SELECT EXISTS(
    SELECT 1 FROM public.event_members
    WHERE event_id = p_event_id AND user_id = v_user
  ) INTO v_is_member;

  IF NOT v_is_member THEN
    RAISE EXCEPTION 'not_an_event_member';
  END IF;

  -- Validate random assignment mode if enabled
  IF p_random_assignment_enabled THEN
    IF p_random_assignment_mode IS NULL OR
       p_random_assignment_mode NOT IN ('one_per_member', 'distribute_all') THEN
      RAISE EXCEPTION 'invalid_random_assignment_mode';
    END IF;
  END IF;

  -- Input validation
  IF p_name IS NULL OR trim(p_name) = '' THEN
    RAISE EXCEPTION 'list_name_required';
  END IF;

  IF length(trim(p_name)) > 255 THEN
    RAISE EXCEPTION 'list_name_too_long';
  END IF;

  -- All operations are atomic within this function (implicit transaction)
  -- If any step fails, entire function rolls back automatically

  -- Create list with all fields including random assignment settings
  INSERT INTO public.lists (
    event_id,
    name,
    created_by,
    visibility,
    custom_recipient_name,
    random_assignment_enabled,
    random_assignment_mode,
    random_receiver_assignment_enabled,
    for_everyone
  )
  VALUES (
    p_event_id,
    trim(p_name),
    v_user,
    COALESCE(p_visibility, 'event'),
    p_custom_recipient_name,
    p_random_assignment_enabled,
    CASE WHEN p_random_assignment_enabled THEN p_random_assignment_mode ELSE NULL END,
    p_random_receiver_assignment_enabled,
    p_for_everyone
  )
  RETURNING id INTO v_list_id;

  -- Add recipients (per-recipient can_view flag)
  IF array_length(p_recipients, 1) IS NOT NULL THEN
    INSERT INTO public.list_recipients (list_id, user_id, can_view)
    SELECT v_list_id, r, NOT (r = ANY(COALESCE(p_hidden_recipients, '{}')))
    FROM unnest(p_recipients) AS r
    WHERE r IS NOT NULL;  -- Safety check for NULL UUIDs
  END IF;

  -- Add explicit viewers (only matters when visibility = 'selected')
  IF COALESCE(p_visibility, 'event') = 'selected'
     AND array_length(p_viewers, 1) IS NOT NULL THEN
    INSERT INTO public.list_viewers (list_id, user_id)
    SELECT v_list_id, v
    FROM unnest(p_viewers) AS v
    WHERE v IS NOT NULL  -- Safety check for NULL UUIDs
      AND NOT EXISTS (
        -- Don't duplicate if already a recipient
        SELECT 1 FROM public.list_recipients lr
        WHERE lr.list_id = v_list_id AND lr.user_id = v
      );
  END IF;

  RETURN v_list_id;

EXCEPTION
  WHEN OTHERS THEN
    -- Log the error (PostgreSQL 13+ syntax)
    RAISE WARNING 'create_list_with_people failed: % %', SQLERRM, SQLSTATE;
    -- Re-raise the exception to rollback transaction
    RAISE;
END;
$function$
"
public,create_list_with_people,"p_event_id uuid, p_name text, p_visibility list_visibility DEFAULT 'event'::list_visibility, p_recipients uuid[] DEFAULT '{}'::uuid[], p_hidden_recipients uuid[] DEFAULT '{}'::uuid[], p_viewers uuid[] DEFAULT '{}'::uuid[]","CREATE OR REPLACE FUNCTION public.create_list_with_people(p_event_id uuid, p_name text, p_visibility list_visibility DEFAULT 'event'::list_visibility, p_recipients uuid[] DEFAULT '{}'::uuid[], p_hidden_recipients uuid[] DEFAULT '{}'::uuid[], p_viewers uuid[] DEFAULT '{}'::uuid[])
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare
  v_user    uuid := auth.uid();
  v_list_id uuid;
begin
  -- Authentication check
  if v_user is null then
    raise exception 'not_authenticated';
  end if;

  -- Validate list name (not empty after trimming)
  if trim(coalesce(p_name, '')) = '' then
    raise exception 'invalid_parameter: name_required';
  end if;

  -- Validate event_id exists and user is a member
  if not public.is_event_member(p_event_id, v_user) then
    raise exception 'not_authorized: must_be_event_member';
  end if;

  -- Validate visibility value
  if p_visibility not in ('event', 'selected', 'public') then
    raise exception 'invalid_parameter: invalid_visibility';
  end if;

  -- Create list
  insert into public.lists (event_id, name, created_by, visibility)
  values (p_event_id, trim(p_name), v_user, coalesce(p_visibility, 'event'))
  returning id into v_list_id;

  -- Add recipients
  if array_length(p_recipients, 1) is not null then
    insert into public.list_recipients (list_id, user_id, can_view)
    select v_list_id, r, not (r = any(coalesce(p_hidden_recipients, '{}')))
    from unnest(p_recipients) as r;
  end if;

  -- Add viewers for 'selected' visibility
  if coalesce(p_visibility, 'event') = 'selected'
     and array_length(p_viewers, 1) is not null then
    insert into public.list_viewers (list_id, user_id)
    select v_list_id, v
    from unnest(p_viewers) as v;
  end if;

  return v_list_id;
end;
$function$
"
public,debug_my_claims,,"CREATE OR REPLACE FUNCTION public.debug_my_claims()
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  DECLARE
    result jsonb;
  BEGIN
    SELECT jsonb_build_object(
      'user_id', auth.uid(),
      'claim_count', (SELECT COUNT(*) FROM claims WHERE claimer_id =
  auth.uid()),
      'claims_visible', (
        SELECT jsonb_agg(jsonb_build_object(
          'id', c.id,
          'item_id', c.item_id,
          'item_name', i.name
        ))
        FROM claims c
        LEFT JOIN items i ON i.id = c.item_id
        WHERE c.claimer_id = auth.uid()
      )
    ) INTO result;

    RETURN result;
  END;
  $function$
"
public,decline_event_invite,p_invite_id uuid,"CREATE OR REPLACE FUNCTION public.decline_event_invite(p_invite_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
BEGIN
  -- Update invite status
  UPDATE public.event_invites
  SET status = 'declined',
      responded_at = now()
  WHERE id = p_invite_id
    AND invitee_id = auth.uid()
    AND status = 'pending';

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Invite not found or already responded';
  END IF;
END;
$function$
"
public,delete_item,p_item_id uuid,"CREATE OR REPLACE FUNCTION public.delete_item(p_item_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_id uuid;
  v_item record;
  v_is_authorized boolean;
  v_event_member_count int;
BEGIN
  v_user_id := auth.uid();

  IF v_user_id IS NULL THEN
    PERFORM log_security_event('delete_item', 'item', p_item_id, false, 'not_authenticated');
    RAISE EXCEPTION 'not_authenticated';
  END IF;

  -- Validate input
  IF p_item_id IS NULL THEN
    RAISE EXCEPTION 'item_id_required';
  END IF;

  -- Rate limit check
  IF NOT check_rate_limit('delete_item', 50, 60) THEN
    RAISE EXCEPTION 'rate_limit_exceeded';
  END IF;

  -- Get item details
  SELECT i.*, l.event_id, l.created_by as list_creator
  INTO v_item
  FROM public.items i
  JOIN public.lists l ON l.id = i.list_id
  WHERE i.id = p_item_id;

  IF NOT FOUND THEN
    PERFORM log_security_event('delete_item', 'item', p_item_id, false, 'not_found');
    RAISE EXCEPTION 'not_found';
  END IF;

  -- Get event member count
  SELECT COUNT(*)
  INTO v_event_member_count
  FROM public.event_members
  WHERE event_id = v_item.event_id;

  -- Check authorization
  SELECT
    -- Item creator
    (v_item.created_by = v_user_id)
    -- OR list creator
    OR (v_item.list_creator = v_user_id)
    -- OR event admin
    OR EXISTS (
      SELECT 1 FROM public.event_members em
      WHERE em.event_id = v_item.event_id
        AND em.user_id = v_user_id
        AND em.role = 'admin'
    )
    -- OR event owner
    OR EXISTS (
      SELECT 1 FROM public.events e
      WHERE e.id = v_item.event_id
        AND e.owner_id = v_user_id
    )
    -- OR last member in event
    OR (v_event_member_count = 1)
  INTO v_is_authorized;

  IF NOT v_is_authorized THEN
    PERFORM log_security_event('delete_item', 'item', p_item_id, false, 'not_authorized');
    RAISE EXCEPTION 'not_authorized';
  END IF;

  -- Check if item has claims
  IF EXISTS (SELECT 1 FROM public.claims WHERE item_id = p_item_id) THEN
    PERFORM log_security_event('delete_item', 'item', p_item_id, false, 'has_claims');
    RAISE EXCEPTION 'has_claims';
  END IF;

  -- Delete item
  DELETE FROM public.items WHERE id = p_item_id;

  -- Log success
  PERFORM log_security_event('delete_item', 'item', p_item_id, true);
END;
$function$
"
public,delete_list,p_list_id uuid,"CREATE OR REPLACE FUNCTION public.delete_list(p_list_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_id uuid;
  v_list record;
  v_is_authorized boolean;
  v_event_member_count int;
BEGIN
  v_user_id := auth.uid();

  IF v_user_id IS NULL THEN
    PERFORM log_security_event('delete_list', 'list', p_list_id, false, 'not_authenticated');
    RAISE EXCEPTION 'not_authenticated';
  END IF;

  -- Validate input
  IF p_list_id IS NULL THEN
    RAISE EXCEPTION 'list_id_required';
  END IF;

  -- Rate limit check
  IF NOT check_rate_limit('delete_list', 20, 60) THEN
    RAISE EXCEPTION 'rate_limit_exceeded';
  END IF;

  -- Get list details
  SELECT l.*, l.event_id, l.created_by
  INTO v_list
  FROM public.lists l
  WHERE l.id = p_list_id;

  IF NOT FOUND THEN
    PERFORM log_security_event('delete_list', 'list', p_list_id, false, 'not_found');
    RAISE EXCEPTION 'not_found';
  END IF;

  -- Get event member count
  SELECT COUNT(*)
  INTO v_event_member_count
  FROM public.event_members
  WHERE event_id = v_list.event_id;

  -- Check authorization
  SELECT
    -- List creator
    (v_list.created_by = v_user_id)
    -- OR event admin
    OR EXISTS (
      SELECT 1 FROM public.event_members em
      WHERE em.event_id = v_list.event_id
        AND em.user_id = v_user_id
        AND em.role = 'admin'
    )
    -- OR event owner
    OR EXISTS (
      SELECT 1 FROM public.events e
      WHERE e.id = v_list.event_id
        AND e.owner_id = v_user_id
    )
    -- OR last member in event
    OR (v_event_member_count = 1)
  INTO v_is_authorized;

  IF NOT v_is_authorized THEN
    PERFORM log_security_event('delete_list', 'list', p_list_id, false, 'not_authorized');
    RAISE EXCEPTION 'not_authorized';
  END IF;

  -- Delete list (CASCADE will delete items and claims)
  DELETE FROM public.lists WHERE id = p_list_id;

  -- Log success
  PERFORM log_security_event('delete_list', 'list', p_list_id, true);
END;
$function$
"
public,deny_claim_split,p_request_id uuid,"CREATE OR REPLACE FUNCTION public.deny_claim_split(p_request_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_request record;
BEGIN
  -- Validate user is authenticated
  IF auth.uid() IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  -- Get the request details
  SELECT * INTO v_request
  FROM public.claim_split_requests
  WHERE id = p_request_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Split request not found';
  END IF;

  -- Validate user is the original claimer
  IF v_request.original_claimer_id != auth.uid() THEN
    RAISE EXCEPTION 'Only the original claimer can deny this request';
  END IF;

  -- Validate request is still pending
  IF v_request.status != 'pending' THEN
    RAISE EXCEPTION 'Request has already been responded to';
  END IF;

  -- Update the request status
  UPDATE public.claim_split_requests
  SET
    status = 'denied',
    responded_at = now()
  WHERE id = p_request_id;
END;
$function$
"
public,ensure_event_owner_member,,"CREATE OR REPLACE FUNCTION public.ensure_event_owner_member()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  if new.owner_id is not null then
    insert into public.event_members(event_id, user_id, role)
    values (new.id, new.owner_id, 'admin')
    on conflict (event_id, user_id)
    do update set role = excluded.role
    where event_members.role <> 'admin';
  end if;
  return new;
end;
$function$
"
public,event_claim_counts_for_user,p_event_ids uuid[],"CREATE OR REPLACE FUNCTION public.event_claim_counts_for_user(p_event_ids uuid[])
 RETURNS TABLE(event_id uuid, claim_count integer)
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  with me as (select auth.uid() as uid),

  visible_lists as (
    select l.id, l.event_id
    from public.lists l, me
    where l.event_id = any(p_event_ids)
      and public.can_view_list(l.id, (select uid from me))
      and not exists (
        select 1 from public.list_recipients lr
        where lr.list_id = l.id
          and lr.user_id = (select uid from me)
      )
  ),

  items_by_event as (
    select i.id as item_id, vl.event_id
    from public.items i
    join visible_lists vl on vl.id = i.list_id
  ),

  claims_on_visible as (
    select ibe.event_id
    from public.claims c
    join items_by_event ibe on ibe.item_id = c.item_id
  )

  select event_id, count(*)::int as claim_count
  from claims_on_visible
  group by event_id;
$function$
"
public,event_id_for_item,i_id uuid,"CREATE OR REPLACE FUNCTION public.event_id_for_item(i_id uuid)
 RETURNS uuid
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  select l.event_id
  from public.items i
  join public.lists l on l.id = i.list_id
  where i.id = i_id
$function$
"
public,event_id_for_list,uuid,"CREATE OR REPLACE FUNCTION public.event_id_for_list(uuid)
 RETURNS uuid
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT event_id FROM public.lists WHERE id = $1
$function$
"
public,event_is_accessible,"p_event_id uuid, p_user uuid","CREATE OR REPLACE FUNCTION public.event_is_accessible(p_event_id uuid, p_user uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
    with ranked as (
      select e.id,
             row_number() over (partition by em.user_id order by e.created_at desc, e.id) rn
      from public.events e
      join public.event_members em on em.event_id = e.id
      where em.user_id = p_user
    )
    select case
      when public.is_pro(p_user, now()) then true
      else exists(select 1 from ranked r where r.id = p_event_id and r.rn <= 3)
    end;
  $function$
"
public,events_for_current_user,,"CREATE OR REPLACE FUNCTION public.events_for_current_user()
 RETURNS TABLE(id uuid, title text, event_date date, join_code text, created_at timestamp with time zone, member_count bigint, total_items bigint, claimed_count bigint, accessible boolean, rownum integer, my_claims bigint, my_unpurchased_claims bigint)
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  WITH me AS (
    SELECT auth.uid() AS uid
  ),
  my_events AS (
    SELECT e.*
    FROM events e
    JOIN event_members em ON em.event_id = e.id
    JOIN me ON me.uid = em.user_id
  ),
  counts AS (
    SELECT
      l.event_id,
      count(DISTINCT l.id) AS list_count,
      count(i.id) AS total_items
    FROM lists l
    LEFT JOIN items i ON i.list_id = l.id
    GROUP BY l.event_id
  ),
  claim_counts AS (
    -- NEW LOGIC: Count CLAIMED ITEMS from ALL visible lists (not just lists I created)
    -- Exclude lists where I'm the recipient (to protect gift surprises)
    -- This matches EventDetailScreen's totalClaimsVisible calculation
    SELECT
      l.event_id,
      COUNT(DISTINCT i.id) AS claimed_count
    FROM lists l
    JOIN items i ON i.list_id = l.id
    WHERE
      -- User can view this list (uses can_view_list for privacy/visibility checks)
      public.can_view_list(l.id, (SELECT uid FROM me)) = true
      -- AND user is NOT a recipient on this list (gift surprise protection)
      AND NOT EXISTS (
        SELECT 1 FROM list_recipients lr
        WHERE lr.list_id = l.id AND lr.user_id = (SELECT uid FROM me)
      )
      -- AND item has at least one claim
      AND EXISTS (
        SELECT 1 FROM claims c WHERE c.item_id = i.id
      )
    GROUP BY l.event_id
  ),
  ranked AS (
    SELECT
      e.id,
      e.title,
      e.event_date,
      e.join_code,
      e.created_at,
      (SELECT count(*) FROM event_members em2 WHERE em2.event_id = e.id) AS member_count,
      COALESCE(ct.total_items, 0) AS total_items,
      COALESCE(cc.claimed_count, 0) AS claimed_count,
      COALESCE(ems.total_claims, 0) AS my_claims,
      COALESCE(ems.unpurchased_claims, 0) AS my_unpurchased_claims,
      row_number() OVER (ORDER BY e.created_at ASC NULLS LAST, e.id) AS rownum
    FROM my_events e
    LEFT JOIN counts ct ON ct.event_id = e.id
    LEFT JOIN claim_counts cc ON cc.event_id = e.id
    LEFT JOIN event_member_stats ems ON ems.event_id = e.id AND ems.user_id = (SELECT uid FROM me)
  )
  SELECT
    r.id,
    r.title,
    r.event_date,
    r.join_code,
    r.created_at,
    r.member_count,
    r.total_items,
    r.claimed_count,
    (r.rownum <= public.allowed_event_slots()) AS accessible,
    r.rownum,
    r.my_claims,
    r.my_unpurchased_claims
  FROM ranked r
  ORDER BY r.created_at DESC NULLS LAST, r.id;
$function$
"
public,events_for_current_user_optimized,,"CREATE OR REPLACE FUNCTION public.events_for_current_user_optimized()
 RETURNS TABLE(id uuid, title text, event_date date, join_code text, created_at timestamp with time zone, member_count bigint, total_items bigint, claimed_count bigint, accessible boolean, rownum integer, my_claims bigint, my_unpurchased_claims bigint, members jsonb, member_user_ids uuid[])
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  WITH me AS (
    SELECT auth.uid() AS uid
  ),
  my_events AS (
    SELECT e.*
    FROM events e
    JOIN event_members em ON em.event_id = e.id
    CROSS JOIN me
    WHERE em.user_id = me.uid
  ),
  counts AS (
    SELECT
      l.event_id,
      count(DISTINCT l.id) AS list_count,
      count(i.id) AS total_items
    FROM lists l
    LEFT JOIN items i ON i.list_id = l.id
    GROUP BY l.event_id
  ),
  claims AS (
    -- Show claims on lists created by current user
    SELECT l.event_id, count(DISTINCT c.id) AS claimed_count
    FROM lists l
    JOIN items i ON i.list_id = l.id
    LEFT JOIN claims c ON c.item_id = i.id
    CROSS JOIN me
    WHERE l.created_by = me.uid
    GROUP BY l.event_id
  ),
  event_members_with_profiles AS (
    -- Get all members with their profile names for events user is in
    SELECT
      em.event_id,
      em.user_id,
      COALESCE(p.display_name, '') AS display_name
    FROM event_members em
    LEFT JOIN profiles p ON p.id = em.user_id
    WHERE em.event_id IN (SELECT id FROM my_events)
  ),
  ranked AS (
    SELECT
      e.id,
      e.title,
      e.event_date,
      e.join_code,
      e.created_at,
      (SELECT count(*) FROM event_members em2 WHERE em2.event_id = e.id) AS member_count,
      COALESCE(ct.total_items, 0) AS total_items,
      COALESCE(cl.claimed_count, 0) AS claimed_count,
      COALESCE(ems.total_claims, 0) AS my_claims,
      COALESCE(ems.unpurchased_claims, 0) AS my_unpurchased_claims,
      row_number() OVER (ORDER BY e.created_at ASC NULLS LAST, e.id) AS rownum,
      -- Aggregate members with profile names into JSONB array
      (
        SELECT jsonb_agg(
          jsonb_build_object(
            'user_id', emp.user_id,
            'display_name', emp.display_name
          )
        )
        FROM event_members_with_profiles emp
        WHERE emp.event_id = e.id
      ) AS members,
      -- Also provide array of user IDs for backward compatibility
      (
        SELECT array_agg(emp.user_id)
        FROM event_members_with_profiles emp
        WHERE emp.event_id = e.id
      ) AS member_user_ids
    FROM my_events e
    LEFT JOIN counts ct ON ct.event_id = e.id
    LEFT JOIN claims cl ON cl.event_id = e.id
    LEFT JOIN event_member_stats ems ON ems.event_id = e.id AND ems.user_id = (SELECT uid FROM me)
  )
  SELECT
    r.id,
    r.title,
    r.event_date,
    r.join_code,
    r.created_at,
    r.member_count,
    r.total_items,
    r.claimed_count,
    (r.rownum <= public.allowed_event_slots()) AS accessible,
    r.rownum,
    r.my_claims,
    r.my_unpurchased_claims,
    COALESCE(r.members, '[]'::jsonb) AS members,
    COALESCE(r.member_user_ids, ARRAY[]::uuid[]) AS member_user_ids
  FROM ranked r
  ORDER BY r.created_at DESC NULLS LAST, r.id;
$function$
"
public,execute_random_receiver_assignment,p_list_id uuid,"CREATE OR REPLACE FUNCTION public.execute_random_receiver_assignment(p_list_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_list record;
  v_event_id uuid;
  v_items_count integer;
  v_members_count integer;
  v_item record;
  v_giver_id uuid;
  v_recipient_id uuid;
  v_eligible_recipients uuid[];
  v_random_index integer;
  v_retry_count integer;
  v_max_retries integer := 10;
BEGIN
  -- Validate user is authenticated
  IF auth.uid() IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  -- Get list details
  SELECT l.*, l.event_id INTO v_list
  FROM public.lists l
  WHERE l.id = p_list_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'List not found';
  END IF;

  -- Verify user has permission (list creator or event admin)
  IF v_list.created_by != auth.uid() THEN
    IF NOT EXISTS (
      SELECT 1 FROM public.event_members
      WHERE event_id = v_list.event_id
        AND user_id = auth.uid()
        AND role = 'admin'
    ) THEN
      RAISE EXCEPTION 'Only list creator or event admin can execute assignment';
    END IF;
  END IF;

  -- Check if receiver assignment is enabled
  IF NOT v_list.random_receiver_assignment_enabled THEN
    RAISE EXCEPTION 'Random receiver assignment is not enabled for this list';
  END IF;

  -- Get eligible members (all event members who are givers, excluding recipients-only)
  v_event_id := v_list.event_id;

  SELECT COUNT(*) INTO v_members_count
  FROM public.event_members em
  WHERE em.event_id = v_event_id
    AND em.role IN ('giver', 'admin');

  -- Need at least 2 members to assign different givers and receivers
  IF v_members_count < 2 THEN
    RAISE EXCEPTION 'Need at least 2 members to use random receiver assignment';
  END IF;

  -- Get items count
  SELECT COUNT(*) INTO v_items_count
  FROM public.items
  WHERE list_id = p_list_id;

  IF v_items_count = 0 THEN
    RAISE EXCEPTION 'No items in list to assign';
  END IF;

  -- Loop through each item and assign a receiver
  FOR v_item IN
    SELECT i.id, i.list_id
    FROM public.items i
    WHERE i.list_id = p_list_id
  LOOP
    -- Get the giver (assigned_to from claims)
    SELECT c.claimer_id INTO v_giver_id
    FROM public.claims c
    WHERE c.item_id = v_item.id
      AND c.assigned_to IS NOT NULL
    LIMIT 1;

    -- If no giver assigned yet, skip this item
    IF v_giver_id IS NULL THEN
      CONTINUE;
    END IF;

    -- Get eligible recipients (all givers/admins except the giver themselves)
    SELECT ARRAY_AGG(em.user_id) INTO v_eligible_recipients
    FROM public.event_members em
    WHERE em.event_id = v_event_id
      AND em.role IN ('giver', 'admin')
      AND em.user_id != v_giver_id;

    -- If no eligible recipients, skip
    IF v_eligible_recipients IS NULL OR array_length(v_eligible_recipients, 1) = 0 THEN
      CONTINUE;
    END IF;

    -- Randomly select a recipient
    v_random_index := floor(random() * array_length(v_eligible_recipients, 1)) + 1;
    v_recipient_id := v_eligible_recipients[v_random_index];

    -- Update the item with assigned recipient
    UPDATE public.items
    SET assigned_recipient_id = v_recipient_id
    WHERE id = v_item.id;
  END LOOP;

  -- Update the list to mark when receiver assignment was executed
  UPDATE public.lists
  SET random_assignment_executed_at = now()
  WHERE id = p_list_id;

END;
$function$
"
public,generate_and_send_daily_digests,p_hour integer DEFAULT NULL::integer,"CREATE OR REPLACE FUNCTION public.generate_and_send_daily_digests(p_hour integer DEFAULT NULL::integer)
 RETURNS TABLE(digests_sent integer)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_user record;
  v_count int := 0;
  v_target_hour int;
  v_current_day_of_week int;
  v_activity_summary jsonb;
  v_events_affected text[];
  v_title text;
  v_body text;
  v_lookback_interval interval;
  v_user_local_time timestamp with time zone;
  v_user_local_hour int;
  v_user_local_dow int;
begin
  -- Use provided hour or current hour (UTC)
  v_target_hour := coalesce(p_hour, extract(hour from now())::int);

  -- Process each user who has digest enabled
  for v_user in
    select distinct
      p.id as user_id,
      p.display_name,
      p.digest_frequency,
      p.digest_day_of_week,
      p.digest_time_hour,
      coalesce(p.timezone, 'UTC') as timezone
    from public.profiles p
    where p.notification_digest_enabled = true
      -- Only process if they have push tokens
      and exists (
        select 1 from public.push_tokens pt where pt.user_id = p.id
      )
  loop
    -- Convert current UTC time to user's local timezone
    begin
      v_user_local_time := now() AT TIME ZONE v_user.timezone;
      v_user_local_hour := extract(hour from v_user_local_time)::int;
      v_user_local_dow := extract(dow from v_user_local_time)::int;
    exception when others then
      -- If timezone is invalid, fall back to UTC
      v_user_local_time := now();
      v_user_local_hour := extract(hour from v_user_local_time)::int;
      v_user_local_dow := extract(dow from v_user_local_time)::int;
    end;

    -- Check if user's LOCAL time matches their digest schedule
    if v_user_local_hour != v_user.digest_time_hour then
      continue; -- Not the right hour for this user
    end if;

    -- Check day of week for weekly digests
    if v_user.digest_frequency = 'weekly' and v_user_local_dow != v_user.digest_day_of_week then
      continue; -- Not the right day for this user
    end if;

    -- Set lookback interval based on frequency
    v_lookback_interval := case
      when v_user.digest_frequency = 'weekly' then interval '7 days'
      else interval '24 hours'
    end;

    -- Check if user has activity in lookback period
    if not exists (
      select 1
      from public.daily_activity_log dal
      where dal.user_id = v_user.user_id
        and dal.created_at >= now() - v_lookback_interval
        and dal.created_at < now()
    ) then
      continue; -- No activity to report
    end if;

    -- Aggregate activity for this user with event and list details
    with activity_details as (
      select
        dal.event_id,
        dal.activity_type,
        dal.activity_data->>'list_name' as list_name,
        dal.activity_data->>'event_title' as event_title,
        count(*) as count
      from public.daily_activity_log dal
      where dal.user_id = v_user.user_id
        and dal.created_at >= now() - v_lookback_interval
        and dal.created_at < now()
      group by dal.event_id, dal.activity_type, dal.activity_data->>'list_name', dal.activity_data->>'event_title'
    ),
    event_summaries as (
      select
        ad.event_title,
        jsonb_agg(
          jsonb_build_object(
            'activity_type', ad.activity_type,
            'list_name', ad.list_name,
            'count', ad.count
          )
        ) as activities
      from activity_details ad
      group by ad.event_id, ad.event_title
    )
    select
      jsonb_agg(
        jsonb_build_object(
          'event_title', es.event_title,
          'activities', es.activities
        )
      ),
      array_agg(es.event_title)
    into v_activity_summary, v_events_affected
    from event_summaries es;

    -- Build notification title and body with detailed breakdown
    declare
      v_event jsonb;
      v_activity jsonb;
      v_lines text[] := array[]::text[];
      v_event_title text;
      v_list_name text;
      v_activity_type text;
      v_activity_count int;
      v_activity_text text;
    begin
      -- Build detailed lines per event/list
      if v_activity_summary is not null then
        for v_event in select jsonb_array_elements(v_activity_summary)
        loop
          v_event_title := v_event->>'event_title';

          for v_activity in select jsonb_array_elements(v_event->'activities')
          loop
            v_list_name := v_activity->>'list_name';
            v_activity_type := v_activity->>'activity_type';
            v_activity_count := (v_activity->>'count')::int;

            -- Format activity text based on type
            v_activity_text := case v_activity_type
              when 'new_list' then
                v_activity_count || ' new list' || case when v_activity_count > 1 then 's' else '' end
              when 'new_item' then
                v_activity_count || ' new item' || case when v_activity_count > 1 then 's' else '' end
              when 'new_claim' then
                v_activity_count || ' new claim' || case when v_activity_count > 1 then 's' else '' end
              when 'unclaim' then
                v_activity_count || ' unclaim' || case when v_activity_count > 1 then 's' else '' end
              else
                v_activity_count || ' ' || v_activity_type
            end;

            -- Format line: ""Event-List: activity"" or ""Event: activity"" for new_list
            if v_activity_type = 'new_list' then
              v_lines := array_append(v_lines, v_event_title || ': ' || v_activity_text);
            else
              v_lines := array_append(v_lines, v_event_title || '-' || coalesce(v_list_name, 'Unknown') || ': ' || v_activity_text);
            end if;
          end loop;
        end loop;
      end if;

      -- Skip if no lines generated
      if array_length(v_lines, 1) is null or array_length(v_lines, 1) = 0 then
        continue;
      end if;

      v_title := case
        when v_user.digest_frequency = 'weekly' then 'Your Weekly GiftCircles Summary'
        else 'Your Daily GiftCircles Summary'
      end;

      -- Join lines with newlines for the body
      v_body := array_to_string(v_lines, E'\n');

      -- Queue notification
      insert into public.notification_queue (user_id, title, body, data)
      values (
        v_user.user_id,
        v_title,
        v_body,
        jsonb_build_object(
          'type', 'digest',
          'frequency', v_user.digest_frequency,
          'summary', v_activity_summary
        )
      );

      v_count := v_count + 1;
    end;
  end loop;

  return query select v_count;
end;
$function$
"
public,get_available_members_for_assignment,p_list_id uuid,"CREATE OR REPLACE FUNCTION public.get_available_members_for_assignment(p_list_id uuid)
 RETURNS uuid[]
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_event_id uuid;
  v_list_creator uuid;
  v_random_receiver_enabled boolean;
  v_member_ids uuid[];
BEGIN
  -- Get list details
  SELECT event_id, created_by, COALESCE(random_receiver_assignment_enabled, false)
  INTO v_event_id, v_list_creator, v_random_receiver_enabled
  FROM public.lists
  WHERE id = p_list_id;

  IF v_event_id IS NULL THEN
    RAISE EXCEPTION 'list_not_found';
  END IF;

  -- Get all event members
  -- ONLY exclude recipients if random_receiver_assignment is NOT enabled
  -- When receiver assignment IS enabled, recipients should also be givers (Secret Santa style)
  IF v_random_receiver_enabled THEN
    -- Include all event members (don't exclude recipients)
    SELECT array_agg(em.user_id ORDER BY random())
    INTO v_member_ids
    FROM public.event_members em
    WHERE em.event_id = v_event_id;
  ELSE
    -- Exclude recipients (old behavior for simple random giver assignment)
    SELECT array_agg(em.user_id ORDER BY random())
    INTO v_member_ids
    FROM public.event_members em
    WHERE em.event_id = v_event_id
      AND NOT EXISTS (
        SELECT 1 FROM public.list_recipients lr
        WHERE lr.list_id = p_list_id AND lr.user_id = em.user_id
      );
  END IF;

  RETURN COALESCE(v_member_ids, ARRAY[]::uuid[]);
END;
$function$
"
public,get_claim_counts_by_list,p_list_ids uuid[],"CREATE OR REPLACE FUNCTION public.get_claim_counts_by_list(p_list_ids uuid[])
 RETURNS TABLE(list_id uuid, claimed_count bigint)
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_id uuid;
BEGIN
  v_user_id := auth.uid();

  -- Return claim counts (number of items with at least 1 claim) for each list
  -- For combined random assignment: all members see total count (collaborative mode)
  -- For single random assignment modes: counts filtered by user visibility

  RETURN QUERY
  WITH visible_lists AS (
    -- Filter to only lists the user can view
    SELECT
      l.id,
      l.event_id,
      l.visibility,
      l.created_by,
      l.random_assignment_enabled,
      l.random_receiver_assignment_enabled
    FROM lists l
    WHERE l.id = ANY(p_list_ids)
      AND (
        -- User created the list
        l.created_by = v_user_id
        -- OR user is a recipient
        OR EXISTS (
          SELECT 1 FROM list_recipients lr
          WHERE lr.list_id = l.id AND lr.user_id = v_user_id
        )
        -- OR list visibility is 'event' and user is event member
        OR (
          l.visibility = 'event'
          AND EXISTS (
            SELECT 1 FROM event_members em
            WHERE em.event_id = l.event_id AND em.user_id = v_user_id
          )
        )
        -- OR list visibility is 'selected' and user is viewer
        OR (
          l.visibility = 'selected'
          AND EXISTS (
            SELECT 1 FROM list_viewers lv
            WHERE lv.list_id = l.id AND lv.user_id = v_user_id
          )
        )
      )
      -- Exclude lists where user is excluded
      AND NOT EXISTS (
        SELECT 1 FROM list_exclusions le
        WHERE le.list_id = l.id AND le.user_id = v_user_id
      )
  ),
  user_permissions AS (
    -- Determine if user is admin/owner for each list
    SELECT
      vl.id as list_id,
      (
        vl.created_by = v_user_id
        OR EXISTS (
          SELECT 1 FROM event_members em
          WHERE em.event_id = vl.event_id
            AND em.user_id = v_user_id
            AND em.role = 'admin'
        )
        OR EXISTS (
          SELECT 1 FROM events e
          WHERE e.id = vl.event_id AND e.owner_id = v_user_id
        )
      ) as is_admin,
      -- Check if this is combined random assignment (collaborative mode)
      (
        vl.random_assignment_enabled = true
        AND vl.random_receiver_assignment_enabled = true
      ) as is_collaborative
    FROM visible_lists vl
  ),
  visible_items AS (
    -- Get items the user can see based on list mode
    SELECT DISTINCT i.id as item_id, i.list_id
    FROM items i
    INNER JOIN visible_lists vl ON vl.id = i.list_id
    INNER JOIN user_permissions up ON up.list_id = vl.id
    WHERE
      -- For combined random assignment (collaborative): all members see all items
      up.is_collaborative = true
      -- OR admins/owners/creators always see all items
      OR up.is_admin = true
      -- OR for random giver assignment only: only see items assigned to you
      OR (
        vl.random_assignment_enabled = true
        AND COALESCE(vl.random_receiver_assignment_enabled, false) = false
        AND EXISTS (
          SELECT 1 FROM claims c
          WHERE c.item_id = i.id AND c.assigned_to = v_user_id
        )
      )
      -- OR for random receiver assignment only: hide from assigned recipients
      OR (
        COALESCE(vl.random_assignment_enabled, false) = false
        AND vl.random_receiver_assignment_enabled = true
        AND i.assigned_recipient_id != v_user_id
      )
      -- OR for non-random lists: see all items
      OR (
        COALESCE(vl.random_assignment_enabled, false) = false
        AND COALESCE(vl.random_receiver_assignment_enabled, false) = false
      )
  ),
  items_with_claims AS (
    -- Get visible items that have at least one claim
    SELECT DISTINCT vi.list_id, vi.item_id
    FROM visible_items vi
    WHERE EXISTS (
      SELECT 1 FROM claims c WHERE c.item_id = vi.item_id
    )
  )
  SELECT
    vl.id as list_id,
    COALESCE(COUNT(iwc.item_id), 0) as claimed_count
  FROM visible_lists vl
  LEFT JOIN items_with_claims iwc ON iwc.list_id = vl.id
  GROUP BY vl.id;
END;
$function$
"
public,get_list_recipients,p_list_id uuid,"CREATE OR REPLACE FUNCTION public.get_list_recipients(p_list_id uuid)
 RETURNS TABLE(list_id uuid, user_id uuid, recipient_email text, display_name text, is_registered boolean, is_event_member boolean)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
begin
  return query
  select
    lr.list_id,
    lr.user_id,
    lr.recipient_email,
    coalesce(p.display_name, lr.recipient_email) as display_name,
    lr.user_id is not null as is_registered,
    exists (
      select 1 from public.event_members em
      join public.lists l on l.event_id = em.event_id
      where l.id = lr.list_id
        and em.user_id = lr.user_id
    ) as is_event_member
  from public.list_recipients lr
  left join public.profiles p on p.id = lr.user_id
  where lr.list_id = p_list_id;
end;
$function$
"
public,get_my_pending_invites,,"CREATE OR REPLACE FUNCTION public.get_my_pending_invites()
 RETURNS TABLE(invite_id uuid, event_id uuid, event_title text, event_date date, inviter_name text, invited_at timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
begin
  return query
  select
    ei.id as invite_id,
    e.id as event_id,
    e.title as event_title,
    e.event_date,
    coalesce(p.display_name, u.email) as inviter_name,
    ei.invited_at
  from public.event_invites ei
  join public.events e on e.id = ei.event_id
  join auth.users u on u.id = ei.inviter_id
  left join public.profiles p on p.id = ei.inviter_id
  where ei.invitee_id = auth.uid()
    and ei.status = 'pending'
  order by ei.invited_at desc;
end;
$function$
"
public,get_my_split_requests,,"CREATE OR REPLACE FUNCTION public.get_my_split_requests()
 RETURNS TABLE(request_id uuid, item_id uuid, item_name text, event_id uuid, event_title text, list_name text, requester_id uuid, requester_name text, created_at timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- Validate user is authenticated
  IF auth.uid() IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  RETURN QUERY
  SELECT
    csr.id as request_id,
    csr.item_id,
    i.name as item_name,
    l.event_id,
    e.title as event_title,
    l.name as list_name,
    csr.requester_id,
    COALESCE(p.display_name, 'Unknown User') as requester_name,
    csr.created_at
  FROM public.claim_split_requests csr
  JOIN public.items i ON csr.item_id = i.id
  JOIN public.lists l ON i.list_id = l.id
  JOIN public.events e ON l.event_id = e.id
  LEFT JOIN public.profiles p ON csr.requester_id = p.id
  WHERE csr.original_claimer_id = auth.uid()
    AND csr.status = 'pending'
  ORDER BY csr.created_at DESC;
END;
$function$
"
public,grant_manual_pro,"p_user_id uuid, p_grant boolean DEFAULT true","CREATE OR REPLACE FUNCTION public.grant_manual_pro(p_user_id uuid, p_grant boolean DEFAULT true)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  UPDATE public.profiles
  SET manual_pro = p_grant
  WHERE id = p_user_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'User not found: %', p_user_id;
  END IF;
END;
$function$
"
public,handle_new_user,,"CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_email text;
  v_display_name text;
  v_invite_record record;
begin
  v_email := lower(trim(new.email));

  -- Extract display name from metadata
  if new.raw_user_meta_data is not null and new.raw_user_meta_data->>'full_name' is not null then
    v_display_name := trim(new.raw_user_meta_data->>'full_name');
  else
    v_display_name := split_part(v_email, '@', 1);
  end if;

  -- Create or update profile
  insert into public.profiles (id, display_name)
  values (new.id, v_display_name)
  on conflict (id) do nothing;

  -- Auto-accept any pending invites with the invited_role
  for v_invite_record in
    select event_id, invited_role
    from public.event_invites
    where lower(invitee_email) = v_email
      and status = 'pending'
  loop
    -- Add user to event with the role specified in the invite
    insert into public.event_members (event_id, user_id, role)
    values (v_invite_record.event_id, new.id, v_invite_record.invited_role)
    on conflict (event_id, user_id) do nothing;

    -- Mark invite as accepted
    update public.event_invites
    set status = 'accepted',
        invitee_id = new.id,
        responded_at = now()
    where event_id = v_invite_record.event_id
      and lower(invitee_email) = v_email;
  end loop;

  return new;
end;
$function$
"
public,initialize_event_member_stats,,"CREATE OR REPLACE FUNCTION public.initialize_event_member_stats()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- When a new event member is added, initialize their stats
  IF TG_OP = 'INSERT' THEN
    INSERT INTO event_member_stats (event_id, user_id, total_claims, unpurchased_claims)
    VALUES (NEW.event_id, NEW.user_id, 0, 0)
    ON CONFLICT (event_id, user_id) DO NOTHING;
  END IF;

  RETURN NEW;
END;
$function$
"
public,is_event_admin,"e_id uuid, u_id uuid","CREATE OR REPLACE FUNCTION public.is_event_admin(e_id uuid, u_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
  select exists(select 1 from public.event_members em where em.event_id=e_id and em.user_id=u_id and em.role='admin')
$function$
"
public,is_event_admin,e_id uuid,"CREATE OR REPLACE FUNCTION public.is_event_admin(e_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE
 SET search_path TO ''
AS $function$
  SELECT EXISTS (
    SELECT 1
    FROM public.event_members em
    WHERE em.event_id = e_id
      AND em.user_id  = auth.uid()
      AND em.role     = 'admin'
  );
$function$
"
public,is_event_member,"e_id uuid, u_id uuid","CREATE OR REPLACE FUNCTION public.is_event_member(e_id uuid, u_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
  select exists(select 1 from public.event_members em
                where em.event_id = e_id and em.user_id = u_id)
$function$
"
public,is_event_member,p_event_id uuid,"CREATE OR REPLACE FUNCTION public.is_event_member(p_event_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE
 SET search_path TO ''
AS $function$
  SELECT EXISTS (
    SELECT 1
    FROM public.event_members em
    WHERE em.event_id = p_event_id
      AND em.user_id  = auth.uid()
  );
$function$
"
public,is_last_event_member,"e_id uuid, u_id uuid","CREATE OR REPLACE FUNCTION public.is_last_event_member(e_id uuid, u_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE
 SET search_path TO ''
AS $function$
  SELECT
    -- User must be a member
    EXISTS (
      SELECT 1 FROM public.event_members
      WHERE event_id = e_id AND user_id = u_id
    )
    AND
    -- Only one member total
    (SELECT count(*) FROM public.event_members WHERE event_id = e_id) = 1
$function$
"
public,is_list_recipient,"l_id uuid, u_id uuid","CREATE OR REPLACE FUNCTION public.is_list_recipient(l_id uuid, u_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  select exists(
    select 1
    from public.list_recipients lr
    where lr.list_id = l_id and lr.user_id = u_id
  )
$function$
"
public,is_member_of_event,"e_id uuid, u_id uuid","CREATE OR REPLACE FUNCTION public.is_member_of_event(e_id uuid, u_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT public.is_member_of_event_secure(e_id, u_id);
$function$
"
public,is_member_of_event,p_event uuid,"CREATE OR REPLACE FUNCTION public.is_member_of_event(p_event uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT public.is_member_of_event_secure(p_event, auth.uid());
$function$
"
public,is_member_of_event_secure,"p_event_id uuid, p_user_id uuid","CREATE OR REPLACE FUNCTION public.is_member_of_event_secure(p_event_id uuid, p_user_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT EXISTS (
    SELECT 1
    FROM public.event_members
    WHERE event_id = p_event_id
      AND user_id = p_user_id
  );
$function$
"
public,is_pro,"p_user uuid, p_at timestamp with time zone DEFAULT now()","CREATE OR REPLACE FUNCTION public.is_pro(p_user uuid, p_at timestamp with time zone DEFAULT now())
 RETURNS boolean
 LANGUAGE sql
 STABLE
AS $function$
  select coalesce(
    (select
      -- User is pro if ANY of these are true:
      manual_pro = true                                    -- Manual override
      OR plan = 'pro'                                      -- RevenueCat set to pro
      OR (pro_until is not null and pro_until >= p_at)   -- Pro subscription not expired
     from public.profiles
     where id = p_user
    ),
    false
  );
$function$
"
public,is_pro_v2,"p_user uuid, p_at timestamp with time zone DEFAULT now()","CREATE OR REPLACE FUNCTION public.is_pro_v2(p_user uuid, p_at timestamp with time zone DEFAULT now())
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  until_ts timestamptz;
begin
  if p_user is null then
    return false;
  end if;

  if to_regclass('public.user_plans') is null then
    return false;
  end if;

  select pro_until into until_ts
  from public.user_plans
  where user_id = p_user;

  return coalesce(until_ts >= p_at, false);
end;
$function$
"
public,is_sole_event_member,"p_event_id uuid, p_user_id uuid","CREATE OR REPLACE FUNCTION public.is_sole_event_member(p_event_id uuid, p_user_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  RETURN (
    SELECT COUNT(*) = 1
    FROM public.event_members
    WHERE event_id = p_event_id
  ) AND (
    SELECT EXISTS(
      SELECT 1
      FROM public.event_members
      WHERE event_id = p_event_id
        AND user_id = p_user_id
    )
  );
END;
$function$
"
public,join_event,p_code text,"CREATE OR REPLACE FUNCTION public.join_event(p_code text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_event_id uuid;
  v_user_id  uuid := auth.uid();
begin
  -- Authentication check
  if v_user_id is null then
    raise exception 'not_authenticated';
  end if;

  -- Validate join code (not empty after trimming)
  if trim(coalesce(p_code, '')) = '' then
    raise exception 'invalid_parameter: code_required';
  end if;

  -- Find event by code (case-insensitive, trimmed)
  select id
    into v_event_id
  from public.events
  where upper(join_code) = upper(trim(p_code))
  limit 1;

  if v_event_id is null then
    raise exception 'invalid_join_code';
  end if;

  -- Add user as member
  insert into public.event_members(event_id, user_id, role)
  values (v_event_id, v_user_id, 'giver')
  on conflict (event_id, user_id) do nothing;

  return v_event_id;
end;
$function$
"
public,leave_event,p_event_id uuid,"CREATE OR REPLACE FUNCTION public.leave_event(p_event_id uuid)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_uid uuid := auth.uid();
  v_role public.member_role;
  v_owner uuid;
  v_remaining integer;
  v_admins integer;
  v_new_admin uuid;
  v_deleted boolean := false;
  v_transferred boolean := false;
begin
  if v_uid is null then
    raise exception 'not_authenticated';
  end if;

  select role into v_role
  from public.event_members
  where event_id = p_event_id and user_id = v_uid;
  if not found then
    raise exception 'not_member';
  end if;

  select owner_id into v_owner from public.events where id = p_event_id;

  delete from public.claims c
  using public.items i, public.lists l
  where c.item_id = i.id
    and i.list_id = l.id
    and l.event_id = p_event_id
    and c.claimer_id = v_uid;

  delete from public.list_recipients lr
  using public.lists l2
  where lr.list_id = l2.id
    and l2.event_id = p_event_id
    and lr.user_id = v_uid;

  delete from public.event_members
  where event_id = p_event_id and user_id = v_uid;

  select count(*) into v_remaining
  from public.event_members
  where event_id = p_event_id;

  if v_remaining = 0 then
    delete from public.events where id = p_event_id;
    v_deleted := true;
    return json_build_object('removed', true, 'deleted_event', v_deleted, 'transferred', v_transferred, 'new_admin', null);
  end if;

  select count(*) into v_admins
  from public.event_members
  where event_id = p_event_id and role = 'admin';

  if v_admins = 0 then
    select public._pick_new_admin(p_event_id) into v_new_admin;
    if v_new_admin is not null then
      update public.event_members
      set role = 'admin'
      where event_id = p_event_id and user_id = v_new_admin;
      v_transferred := true;
    end if;
  end if;

  if v_owner = v_uid then
    select user_id into v_new_admin
    from public.event_members
    where event_id = p_event_id and role = 'admin'
    limit 1;

    if v_new_admin is null then
      select public._pick_new_admin(p_event_id) into v_new_admin;
    end if;

    if v_new_admin is not null then
      update public.events set owner_id = v_new_admin where id = p_event_id;
      v_transferred := true;
    end if;
  end if;

  return json_build_object('removed', true, 'deleted_event', v_deleted, 'transferred', v_transferred, 'new_admin', v_new_admin);
end
$function$
"
public,link_list_recipients_on_signup,,"CREATE OR REPLACE FUNCTION public.link_list_recipients_on_signup()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
  v_recipient record;
  v_list_name text;
  v_event_title text;
  v_creator_name text;
BEGIN
  BEGIN
    FOR v_recipient IN
      UPDATE public.list_recipients lr
      SET user_id = NEW.id
      WHERE lower(recipient_email) = lower(NEW.email) AND user_id IS NULL
      RETURNING lr.list_id, lr.recipient_email
    LOOP
      SELECT l.name, e.title INTO v_list_name, v_event_title
      FROM public.lists l JOIN public.events e ON e.id = l.event_id
      WHERE l.id = v_recipient.list_id;

      SELECT coalesce(p.display_name, 'Someone') INTO v_creator_name
      FROM public.lists l LEFT JOIN public.profiles p ON p.id = l.created_by
      WHERE l.id = v_recipient.list_id;

      IF EXISTS (SELECT 1 FROM public.push_tokens WHERE user_id = NEW.id) THEN
        INSERT INTO public.notification_queue (user_id, title, body, data)
        VALUES (
          NEW.id,
          'Gift List Created',
          v_creator_name || ' created a gift list for you in ' || v_event_title,
          jsonb_build_object('type', 'list_for_recipient', 'list_id', v_recipient.list_id)
        );
      END IF;
    END LOOP;
  EXCEPTION WHEN OTHERS THEN
    NULL; -- Don't fail signup
  END;
  RETURN NEW;
END;
$function$
"
public,list_claim_counts_for_user,p_list_ids uuid[],"CREATE OR REPLACE FUNCTION public.list_claim_counts_for_user(p_list_ids uuid[])
 RETURNS TABLE(list_id uuid, claim_count integer)
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  with me as (select auth.uid() as uid),

  visible_lists as (
    select l.id, l.event_id
    from public.lists l, me
    where l.id = any(p_list_ids)
      and public.can_view_list(l.id, (select uid from me))
  ),

  items_by_list as (
    select i.id as item_id, i.list_id
    from public.items i
    join visible_lists vl on vl.id = i.list_id
  ),

  non_recipient_lists as (
    select vl.id as list_id
    from visible_lists vl, me
    where not exists (
      select 1 from public.list_recipients lr
      where lr.list_id = vl.id
        and lr.user_id = (select uid from me)
    )
  ),

  claims_viewable as (
    select i.list_id
    from public.claims c
    join items_by_list i on i.item_id = c.item_id
    where exists (
      select 1 from non_recipient_lists n
      where n.list_id = i.list_id
    )
  ),

  my_claims as (
    select i.list_id
    from public.claims c
    join items_by_list i on i.item_id = c.item_id
    where c.claimer_id = (select uid from me)
  ),

  merged as (
    select list_id from claims_viewable
    union all
    select list_id from my_claims
  )

  select list_id, count(*)::int as claim_count
  from merged
  group by list_id;
$function$
"
public,list_claims_for_user,p_item_ids uuid[],"CREATE OR REPLACE FUNCTION public.list_claims_for_user(p_item_ids uuid[])
 RETURNS TABLE(item_id uuid, claimer_id uuid)
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_id uuid;
BEGIN
  v_user_id := auth.uid();

  IF v_user_id IS NULL THEN
    RETURN;
  END IF;

  RETURN QUERY
  SELECT DISTINCT c.item_id, c.claimer_id
  FROM public.claims c
  INNER JOIN public.items i ON i.id = c.item_id
  INNER JOIN public.lists l ON l.id = i.list_id
  WHERE
    -- Only include items from the requested item IDs
    c.item_id = ANY(p_item_ids)
    -- User must be an event member
    AND EXISTS (
      SELECT 1 FROM public.event_members em
      WHERE em.event_id = l.event_id AND em.user_id = v_user_id
    )
    -- User must not be excluded from the list
    AND NOT EXISTS (
      SELECT 1 FROM public.list_exclusions le
      WHERE le.list_id = l.id AND le.user_id = v_user_id
    )
    -- Apply claim visibility rules
    AND (
      -- Rule 1: Always show your own claims
      c.claimer_id = v_user_id

      -- Rule 2: List creator sees all claims
      OR l.created_by = v_user_id

      -- Rule 3: Event admin sees all claims
      OR EXISTS (
        SELECT 1 FROM public.event_members em
        WHERE em.event_id = l.event_id
          AND em.user_id = v_user_id
          AND em.role = 'admin'
      )

      -- Rule 4: Event owner sees all claims
      OR EXISTS (
        SELECT 1 FROM public.events e
        WHERE e.id = l.event_id AND e.owner_id = v_user_id
      )

      -- Rule 5: Collaborative mode (both random features) - show claims assigned to you
      OR (
        COALESCE(l.random_assignment_enabled, false) = true
        AND COALESCE(l.random_receiver_assignment_enabled, false) = true
        AND c.assigned_to = v_user_id
      )

      -- Rule 6: Non-random lists - show claims if you're NOT a recipient
      OR (
        COALESCE(l.random_assignment_enabled, false) = false
        AND COALESCE(l.random_receiver_assignment_enabled, false) = false
        AND NOT EXISTS (
          SELECT 1 FROM public.list_recipients lr
          WHERE lr.list_id = l.id AND lr.user_id = v_user_id
        )
      )

      -- Rule 7: Single random mode - show assigned claims if NOT a recipient
      OR (
        COALESCE(l.random_assignment_enabled, false) = true
        AND COALESCE(l.random_receiver_assignment_enabled, false) = false
        AND c.assigned_to = v_user_id
        AND NOT EXISTS (
          SELECT 1 FROM public.list_recipients lr
          WHERE lr.list_id = l.id AND lr.user_id = v_user_id
        )
      )
    );
END;
$function$
"
public,list_id_for_item,i_id uuid,"CREATE OR REPLACE FUNCTION public.list_id_for_item(i_id uuid)
 RETURNS uuid
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  select list_id from public.items where id = i_id
$function$
"
public,log_activity_for_digest,"p_event_id uuid, p_list_id uuid, p_exclude_user_id uuid, p_activity_type text, p_activity_data jsonb","CREATE OR REPLACE FUNCTION public.log_activity_for_digest(p_event_id uuid, p_list_id uuid, p_exclude_user_id uuid, p_activity_type text, p_activity_data jsonb)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  -- Log activity for event members who have digest enabled
  -- AND can view this list according to visibility rules
  insert into public.daily_activity_log (user_id, event_id, activity_type, activity_data)
  select
    em.user_id,
    p_event_id,
    p_activity_type,
    p_activity_data
  from public.event_members em
  join public.profiles p on p.id = em.user_id
  where em.event_id = p_event_id
    -- User is not the one who performed the action
    and em.user_id != coalesce(p_exclude_user_id, '00000000-0000-0000-0000-000000000000'::uuid)
    -- User has digest enabled
    and p.notification_digest_enabled = true
    -- User can view this list (respects visibility, exclusions, viewers)
    and public.can_view_list(p_list_id, em.user_id) = true
    -- For claims/unclaims: exclude list recipients (they shouldn't see who claimed/unclaimed their items)
    and (
      p_activity_type not in ('new_claim', 'unclaim')
      or
      not exists (
        select 1
        from public.list_recipients lr
        where lr.list_id = p_list_id
          and lr.user_id = em.user_id
      )
    );
end;
$function$
"
public,log_security_event,"p_action text, p_resource_type text DEFAULT NULL::text, p_resource_id uuid DEFAULT NULL::uuid, p_success boolean DEFAULT true, p_error_message text DEFAULT NULL::text, p_metadata jsonb DEFAULT NULL::jsonb","CREATE OR REPLACE FUNCTION public.log_security_event(p_action text, p_resource_type text DEFAULT NULL::text, p_resource_id uuid DEFAULT NULL::uuid, p_success boolean DEFAULT true, p_error_message text DEFAULT NULL::text, p_metadata jsonb DEFAULT NULL::jsonb)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  INSERT INTO public.security_audit_log (
    user_id,
    action,
    resource_type,
    resource_id,
    success,
    error_message,
    metadata
  )
  VALUES (
    auth.uid(),
    p_action,
    p_resource_type,
    p_resource_id,
    p_success,
    p_error_message,
    p_metadata
  );
EXCEPTION
  WHEN OTHERS THEN
    -- Don't fail the operation if audit logging fails
    RAISE WARNING 'Failed to log security event: %', SQLERRM;
END;
$function$
"
public,mark_orphaned_lists_for_deletion,,"CREATE OR REPLACE FUNCTION public.mark_orphaned_lists_for_deletion()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_event_id UUID;
  v_remaining_user_id UUID;
  v_list RECORD;
BEGIN
  -- Get the event_id from the deleted member
  v_event_id := OLD.event_id;

  -- Check if there's exactly one member left in the event
  SELECT user_id INTO v_remaining_user_id
  FROM public.event_members
  WHERE event_id = v_event_id
  LIMIT 1;

  -- If no members left or more than one member, nothing to do
  IF v_remaining_user_id IS NULL THEN
    RETURN OLD;
  END IF;

  IF NOT is_sole_event_member(v_event_id, v_remaining_user_id) THEN
    RETURN OLD;
  END IF;

  -- Find all lists in this event where the remaining user is excluded
  FOR v_list IN
    SELECT l.id as list_id
    FROM public.lists l
    INNER JOIN public.list_exclusions le ON le.list_id = l.id
    WHERE l.event_id = v_event_id
      AND le.user_id = v_remaining_user_id
  LOOP
    -- Mark this list for deletion (insert or update)
    INSERT INTO public.orphaned_lists (list_id, event_id, excluded_user_id, marked_at, delete_at)
    VALUES (v_list.list_id, v_event_id, v_remaining_user_id, NOW(), NOW() + INTERVAL '30 days')
    ON CONFLICT (list_id, excluded_user_id)
    DO UPDATE SET
      marked_at = NOW(),
      delete_at = NOW() + INTERVAL '30 days';
  END LOOP;

  RETURN OLD;
END;
$function$
"
public,notify_new_claim,,"CREATE OR REPLACE FUNCTION public.notify_new_claim()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  v_item_name text;
  v_list_id uuid;
  v_list_name text;
  v_event_id uuid;
  v_event_title text;
  v_claimer_name text;
begin
  -- Get item and list details
  select i.name, i.list_id
  into v_item_name, v_list_id
  from public.items i
  where i.id = NEW.item_id;

  -- Get list details
  select l.name, l.event_id
  into v_list_name, v_event_id
  from public.lists l
  where l.id = v_list_id;

  -- Get event title
  select title into v_event_title
  from public.events
  where id = v_event_id;

  -- Get claimer name
  select display_name into v_claimer_name
  from public.profiles
  where id = NEW.claimer_id;

  -- Queue instant notification for eligible event members with privacy checks
  -- EXCLUDES list recipients (they should never see who claimed their items)
  perform public.queue_notification_for_list_activity(
    v_list_id,           -- list_id for privacy checks
    v_event_id,
    NEW.claimer_id,      -- exclude claimer
    'item_claimed',
    v_claimer_name || ' claimed ' || v_item_name || ' from ' || v_list_name,
    jsonb_build_object(
      'claim_id', NEW.id,
      'item_id', NEW.item_id,
      'list_id', v_list_id,
      'event_id', v_event_id,
      'item_name', v_item_name,
      'list_name', v_list_name,
      'claimer_name', v_claimer_name,
      'event_title', v_event_title,
      'type', 'item_claimed'
    ),
    true                 -- exclude recipients (they should never see who claimed)
  );

  -- ALSO log activity for digest users (with privacy checks)
  -- This will automatically exclude list recipients via log_activity_for_digest
  perform public.log_activity_for_digest(
    v_event_id,
    v_list_id,           -- Pass list_id for privacy filtering
    NEW.claimer_id,
    'new_claim',
    jsonb_build_object(
      'claim_id', NEW.id,
      'item_id', NEW.item_id,
      'item_name', v_item_name,
      'list_id', v_list_id,
      'list_name', v_list_name,
      'claimer_name', v_claimer_name,
      'event_title', v_event_title
    )
  );

  return NEW;
end;
$function$
"
public,notify_new_item,,"CREATE OR REPLACE FUNCTION public.notify_new_item()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  v_list_id uuid;
  v_list_name text;
  v_event_id uuid;
  v_event_title text;
  v_creator_name text;
begin
  -- Get list details
  select l.id, l.name, l.event_id
  into v_list_id, v_list_name, v_event_id
  from public.lists l
  where l.id = NEW.list_id;

  -- Get event title
  select title into v_event_title
  from public.events
  where id = v_event_id;

  -- Get creator name
  select display_name into v_creator_name
  from public.profiles
  where id = NEW.created_by;

  -- Queue instant notification for eligible event members with privacy checks
  perform public.queue_notification_for_list_activity(
    v_list_id,           -- list_id for privacy checks
    v_event_id,
    NEW.created_by,      -- exclude item creator
    'new_item',
    v_creator_name || ' added an item to ' || v_list_name,
    jsonb_build_object(
      'item_id', NEW.id,
      'list_id', v_list_id,
      'event_id', v_event_id,
      'item_name', NEW.name,
      'list_name', v_list_name,
      'creator_name', v_creator_name,
      'event_title', v_event_title,
      'type', 'new_item'
    ),
    false                -- don't exclude recipients (they can see items added)
  );

  -- ALSO log activity for digest users (with privacy checks)
  perform public.log_activity_for_digest(
    v_event_id,
    v_list_id,           -- Pass list_id for privacy filtering
    NEW.created_by,
    'new_item',
    jsonb_build_object(
      'item_id', NEW.id,
      'item_name', NEW.name,
      'list_id', v_list_id,
      'list_name', v_list_name,
      'creator_name', v_creator_name,
      'event_title', v_event_title
    )
  );

  return NEW;
end;
$function$
"
public,notify_new_list,,"CREATE OR REPLACE FUNCTION public.notify_new_list()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  v_creator_name text;
  v_event_title text;
begin
  -- Get creator name
  select display_name into v_creator_name
  from public.profiles
  where id = NEW.created_by;

  -- Get event title
  select title into v_event_title
  from public.events
  where id = NEW.event_id;

  -- Queue instant notification for eligible event members with privacy checks
  perform public.queue_notification_for_list_activity(
    NEW.id,              -- list_id for privacy checks
    NEW.event_id,
    NEW.created_by,      -- exclude list creator
    'list_created',
    v_creator_name || ' created a new list: ' || NEW.name,
    jsonb_build_object(
      'list_id', NEW.id,
      'event_id', NEW.event_id,
      'creator_name', v_creator_name,
      'list_name', NEW.name,
      'event_title', v_event_title,
      'type', 'list_created'
    ),
    false                -- don't exclude recipients (they can see list creation)
  );

  -- ALSO log activity for digest users (with privacy checks)
  perform public.log_activity_for_digest(
    NEW.event_id,
    NEW.id,              -- Pass list_id for privacy filtering
    NEW.created_by,
    'new_list',
    jsonb_build_object(
      'list_id', NEW.id,
      'list_name', NEW.name,
      'creator_name', v_creator_name,
      'event_title', v_event_title
    )
  );

  return NEW;
end;
$function$
"
public,notify_unclaim,,"CREATE OR REPLACE FUNCTION public.notify_unclaim()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  v_item_name text;
  v_list_id uuid;
  v_list_name text;
  v_event_id uuid;
  v_event_title text;
  v_unclaimer_name text;
begin
  -- Get item and list details
  select i.name, i.list_id
  into v_item_name, v_list_id
  from public.items i
  where i.id = OLD.item_id;

  -- Get list details
  select l.name, l.event_id
  into v_list_name, v_event_id
  from public.lists l
  where l.id = v_list_id;

  -- Get event title
  select title into v_event_title
  from public.events
  where id = v_event_id;

  -- Get unclaimer name
  select display_name into v_unclaimer_name
  from public.profiles
  where id = OLD.claimer_id;

  -- Queue instant notification for eligible event members with privacy checks
  -- EXCLUDES list recipients (they should never see who unclaimed their items)
  perform public.queue_notification_for_list_activity(
    v_list_id,           -- list_id for privacy checks
    v_event_id,
    OLD.claimer_id,      -- exclude unclaimer
    'item_unclaimed',
    v_unclaimer_name || ' unclaimed ' || v_item_name || ' from ' || v_list_name,
    jsonb_build_object(
      'claim_id', OLD.id,
      'item_id', OLD.item_id,
      'list_id', v_list_id,
      'event_id', v_event_id,
      'item_name', v_item_name,
      'list_name', v_list_name,
      'unclaimer_name', v_unclaimer_name,
      'event_title', v_event_title,
      'type', 'item_unclaimed'
    ),
    true                 -- exclude recipients (they should never see who unclaimed)
  );

  -- ALSO log activity for digest users (with privacy checks)
  -- This will automatically exclude list recipients via log_activity_for_digest
  perform public.log_activity_for_digest(
    v_event_id,
    v_list_id,           -- Pass list_id for privacy filtering
    OLD.claimer_id,
    'unclaim',
    jsonb_build_object(
      'claim_id', OLD.id,
      'item_id', OLD.item_id,
      'item_name', v_item_name,
      'list_id', v_list_id,
      'list_name', v_list_name,
      'unclaimer_name', v_unclaimer_name,
      'event_title', v_event_title
    )
  );

  return OLD;
end;
$function$
"
public,queue_notification_for_event_members,"p_event_id uuid, p_exclude_user_id uuid, p_notification_type text, p_title text, p_data jsonb","CREATE OR REPLACE FUNCTION public.queue_notification_for_event_members(p_event_id uuid, p_exclude_user_id uuid, p_notification_type text, p_title text, p_data jsonb)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- Queue notifications for event members who:
  -- 1. Are not the excluded user
  -- 2. Have push tokens registered
  -- 3. Have instant_notifications_enabled = true (opted in)
  --
  -- NOTE: Purchase reminders bypass this check (handled separately)
  INSERT INTO public.notification_queue (user_id, title, body, data)
  SELECT
    em.user_id,
    p_title,
    '', -- Empty body, title contains the message
    p_data
  FROM public.event_members em
  JOIN public.profiles p ON p.id = em.user_id
  WHERE em.event_id = p_event_id
    AND em.user_id != p_exclude_user_id
    -- User has instant notifications enabled (opted in)
    AND p.instant_notifications_enabled = true
    -- User has push tokens
    AND EXISTS (
      SELECT 1
      FROM public.push_tokens pt
      WHERE pt.user_id = em.user_id
    );
END;
$function$
"
public,queue_notification_for_list_activity,"p_list_id uuid, p_event_id uuid, p_exclude_user_id uuid, p_notification_type text, p_title text, p_data jsonb, p_exclude_recipients boolean DEFAULT false","CREATE OR REPLACE FUNCTION public.queue_notification_for_list_activity(p_list_id uuid, p_event_id uuid, p_exclude_user_id uuid, p_notification_type text, p_title text, p_data jsonb, p_exclude_recipients boolean DEFAULT false)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- Queue notifications for event members who:
  -- 1. Are not the excluded user (action creator)
  -- 2. Have push tokens registered
  -- 3. Have instant_notifications_enabled = true (opted in)
  -- 4. Can view the list according to visibility rules (can_view_list checks list_exclusions, visibility, viewers)
  -- 5. For claims/unclaims: Are not list recipients (they should never see who claimed/unclaimed)
  INSERT INTO public.notification_queue (user_id, title, body, data)
  SELECT
    em.user_id,
    p_title,
    '', -- Empty body, title contains the message
    p_data
  FROM public.event_members em
  JOIN public.profiles p ON p.id = em.user_id
  WHERE em.event_id = p_event_id
    -- User is not the one who performed the action
    AND em.user_id != p_exclude_user_id
    -- User has instant notifications enabled (opted in)
    AND p.instant_notifications_enabled = true
    -- User has push tokens
    AND EXISTS (
      SELECT 1
      FROM public.push_tokens pt
      WHERE pt.user_id = em.user_id
    )
    -- User can view this list (respects visibility, exclusions, viewers)
    AND public.can_view_list(p_list_id, em.user_id) = true
    -- For claims/unclaims: exclude list recipients (they should never see who claimed/unclaimed)
    AND (
      p_exclude_recipients = false
      OR
      NOT EXISTS (
        SELECT 1
        FROM public.list_recipients lr
        WHERE lr.list_id = p_list_id
          AND lr.user_id = em.user_id
      )
    );
END;
$function$
"
public,recalculate_event_member_stats,"p_event_id uuid, p_user_id uuid","CREATE OR REPLACE FUNCTION public.recalculate_event_member_stats(p_event_id uuid, p_user_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_total_claims bigint;
  v_unpurchased_claims bigint;
BEGIN
  -- Calculate claim counts for this user in this event
  -- For collaborative mode (both random features): include all claims
  -- For other modes: exclude claims on lists where user is the recipient

  SELECT
    COUNT(c.id),
    COUNT(c.id) FILTER (WHERE c.purchased = false)
  INTO v_total_claims, v_unpurchased_claims
  FROM claims c
  JOIN items i ON i.id = c.item_id
  JOIN lists l ON l.id = i.list_id
  WHERE l.event_id = p_event_id
    AND c.claimer_id = p_user_id
    AND (
      -- Include claims in collaborative mode (both random features enabled)
      (
        COALESCE(l.random_assignment_enabled, false) = true
        AND COALESCE(l.random_receiver_assignment_enabled, false) = true
      )
      -- OR include claims on non-recipient lists
      OR NOT EXISTS (
        SELECT 1 FROM list_recipients lr
        WHERE lr.list_id = l.id AND lr.user_id = p_user_id
      )
    );

  -- Upsert the stats
  INSERT INTO event_member_stats (event_id, user_id, total_claims, unpurchased_claims, updated_at)
  VALUES (p_event_id, p_user_id, v_total_claims, v_unpurchased_claims, now())
  ON CONFLICT (event_id, user_id)
  DO UPDATE SET
    total_claims = EXCLUDED.total_claims,
    unpurchased_claims = EXCLUDED.unpurchased_claims,
    updated_at = now();
END;
$function$
"
public,refresh_event_member_stats,"p_event_id uuid, p_user_id uuid","CREATE OR REPLACE FUNCTION public.refresh_event_member_stats(p_event_id uuid, p_user_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_total_claims integer;
  v_unpurchased_claims integer;
BEGIN
  -- Calculate actual claims for this user in this event
  SELECT
    COUNT(c.id),
    COUNT(c.id) FILTER (WHERE c.purchased = false)
  INTO v_total_claims, v_unpurchased_claims
  FROM claims c
  JOIN items i ON i.id = c.item_id
  JOIN lists l ON l.id = i.list_id
  WHERE l.event_id = p_event_id
    AND c.claimer_id = p_user_id;

  -- Update or insert the stats
  INSERT INTO event_member_stats (event_id, user_id, total_claims, unpurchased_claims, updated_at)
  VALUES (p_event_id, p_user_id, v_total_claims, v_unpurchased_claims, NOW())
  ON CONFLICT (event_id, user_id)
  DO UPDATE SET
    total_claims = v_total_claims,
    unpurchased_claims = v_unpurchased_claims,
    updated_at = NOW();

  -- If no claims left, delete the stats row
  IF v_total_claims = 0 THEN
    DELETE FROM event_member_stats
    WHERE event_id = p_event_id AND user_id = p_user_id;
  END IF;
END;
$function$
"
public,remove_member,"p_event_id uuid, p_user_id uuid","CREATE OR REPLACE FUNCTION public.remove_member(p_event_id uuid, p_user_id uuid)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_actor uuid := auth.uid();
  v_actor_role public.member_role;
  v_owner uuid;
  v_target_role public.member_role;
  v_remaining integer;
  v_admins integer;
  v_new_admin uuid;
  v_deleted boolean := false;
  v_transferred boolean := false;
  v_actor_is_owner boolean := false;
begin
  if v_actor is null then
    raise exception 'not_authenticated';
  end if;
  if p_user_id = v_actor then
    raise exception 'use_leave_event_for_self';
  end if;

  select role into v_actor_role
  from public.event_members
  where event_id = p_event_id and user_id = v_actor;
  if not found then
    raise exception 'not_member';
  end if;

  select owner_id into v_owner from public.events where id = p_event_id;
  v_actor_is_owner := (v_owner = v_actor);

  if v_actor_role <> 'admin' and not v_actor_is_owner then
    raise exception 'not_authorized';
  end if;

  select role into v_target_role
  from public.event_members
  where event_id = p_event_id and user_id = p_user_id;
  if not found then
    raise exception 'target_not_member';
  end if;

  delete from public.claims c
  using public.items i, public.lists l
  where c.item_id = i.id
    and i.list_id = l.id
    and l.event_id = p_event_id
    and c.claimer_id = p_user_id;

  delete from public.list_recipients lr
  using public.lists l2
  where lr.list_id = l2.id
    and l2.event_id = p_event_id
    and lr.user_id = p_user_id;

  delete from public.event_members
  where event_id = p_event_id and user_id = p_user_id;

  select count(*) into v_remaining
  from public.event_members
  where event_id = p_event_id;

  if v_remaining = 0 then
    delete from public.events where id = p_event_id;
    v_deleted := true;
    return json_build_object('removed', true, 'deleted_event', v_deleted, 'transferred', v_transferred, 'new_admin', null);
  end if;

  if v_target_role = 'admin' then
    select count(*) into v_admins
    from public.event_members
    where event_id = p_event_id and role = 'admin';

    if v_admins = 0 then
      select public._pick_new_admin(p_event_id) into v_new_admin;
      if v_new_admin is not null then
        update public.event_members
        set role = 'admin'
        where event_id = p_event_id and user_id = v_new_admin;
        v_transferred := true;
      end if;
    end if;
  end if;

  if v_owner = p_user_id then
    select user_id into v_new_admin
    from public.event_members
    where event_id = p_event_id and role = 'admin'
    limit 1;

    if v_new_admin is null then
      select public._pick_new_admin(p_event_id) into v_new_admin;
    end if;

    if v_new_admin is not null then
      update public.events set owner_id = v_new_admin where id = p_event_id;
      v_transferred := true;
    end if;
  end if;

  return json_build_object('removed', true, 'deleted_event', v_deleted, 'transferred', v_transferred, 'new_admin', v_new_admin);
end
$function$
"
public,request_claim_split,p_item_id uuid,"CREATE OR REPLACE FUNCTION public.request_claim_split(p_item_id uuid)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_original_claimer_id uuid;
  v_request_id uuid;
  v_list_id uuid;
  v_event_id uuid;
BEGIN
  -- Validate user is authenticated
  IF auth.uid() IS NULL THEN
    RAISE EXCEPTION 'Not authenticated';
  END IF;

  -- Get the original claimer (first claimer based on created_at)
  SELECT c.claimer_id INTO v_original_claimer_id
  FROM public.claims c
  WHERE c.item_id = p_item_id
  ORDER BY c.created_at ASC
  LIMIT 1;

  -- Validate item is claimed
  IF v_original_claimer_id IS NULL THEN
    RAISE EXCEPTION 'Item is not claimed';
  END IF;

  -- Validate user is not the original claimer
  IF v_original_claimer_id = auth.uid() THEN
    RAISE EXCEPTION 'Cannot request to split your own claim';
  END IF;

  -- Validate user is not already a claimer
  IF EXISTS (
    SELECT 1 FROM public.claims
    WHERE item_id = p_item_id AND claimer_id = auth.uid()
  ) THEN
    RAISE EXCEPTION 'You have already claimed this item';
  END IF;

  -- Validate user is a member of the event
  SELECT i.list_id, l.event_id INTO v_list_id, v_event_id
  FROM public.items i
  JOIN public.lists l ON i.list_id = l.id
  WHERE i.id = p_item_id;

  IF NOT EXISTS (
    SELECT 1 FROM public.event_members
    WHERE event_id = v_event_id AND user_id = auth.uid()
  ) THEN
    RAISE EXCEPTION 'You are not a member of this event';
  END IF;

  -- Check if there's already a pending request
  IF EXISTS (
    SELECT 1 FROM public.claim_split_requests
    WHERE item_id = p_item_id
      AND requester_id = auth.uid()
      AND original_claimer_id = v_original_claimer_id
      AND status = 'pending'
  ) THEN
    RAISE EXCEPTION 'You already have a pending split request for this item';
  END IF;

  -- Create the split request
  INSERT INTO public.claim_split_requests (
    item_id,
    requester_id,
    original_claimer_id,
    status
  ) VALUES (
    p_item_id,
    auth.uid(),
    v_original_claimer_id,
    'pending'
  )
  RETURNING id INTO v_request_id;

  RETURN v_request_id;
END;
$function$
"
public,rollover_all_due_events,,"CREATE OR REPLACE FUNCTION public.rollover_all_due_events()
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_count int := 0;
  rec record;
  v_new date;
begin
  for rec in
    select e.id, e.event_date, e.recurrence
    from public.events e
    where e.recurrence <> 'none'
      and e.event_date is not null
      and e.event_date <= current_date
      and (e.last_rolled_at is null or e.last_rolled_at < e.event_date)
  loop
    delete from public.items i
    using public.lists l
    where i.list_id = l.id
      and l.event_id = rec.id
      and exists (select 1 from public.claims c where c.item_id = i.id);

    delete from public.claims c
    where not exists (select 1 from public.items i where i.id = c.item_id);

    v_new := _next_occurrence(rec.event_date, rec.recurrence, 1);
    while v_new <= current_date loop
      v_new := _next_occurrence(v_new, rec.recurrence, 1);
    end loop;

    update public.events
       set event_date     = v_new,
           last_rolled_at = current_date
     where id = rec.id;

    v_count := v_count + 1;
  end loop;

  return v_count;
end
$function$
"
public,sanitize_text,"p_text text, p_max_length integer DEFAULT 1000","CREATE OR REPLACE FUNCTION public.sanitize_text(p_text text, p_max_length integer DEFAULT 1000)
 RETURNS text
 LANGUAGE plpgsql
 IMMUTABLE
 SET search_path TO ''
AS $function$
BEGIN
  IF p_text IS NULL THEN
    RETURN NULL;
  END IF;

  -- Trim whitespace and limit length
  RETURN substring(trim(p_text) from 1 for p_max_length);
END;
$function$
"
public,send_event_invite,"p_event_id uuid, p_inviter_email text, p_recipient_email text","CREATE OR REPLACE FUNCTION public.send_event_invite(p_event_id uuid, p_inviter_email text, p_recipient_email text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_invite_id uuid;
  v_admin_only_invites boolean;
  v_is_admin boolean;
begin
  -- Check if event has admin-only invites restriction
  select admin_only_invites into v_admin_only_invites
  from public.events
  where id = p_event_id;

  -- If admin-only invites is enabled, verify user is admin
  if v_admin_only_invites then
    select exists (
      select 1 from public.event_members
      where event_id = p_event_id
        and user_id = auth.uid()
        and role = 'admin'
    ) into v_is_admin;

    if not v_is_admin then
      raise exception 'Only admins can invite to this event';
    end if;
  end if;

  -- Validate email format
  if p_recipient_email !~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$' then
    raise exception 'invalid_email';
  end if;

  -- Insert invite
  insert into public.event_invites (event_id, inviter_email, recipient_email)
  values (p_event_id, p_inviter_email, p_recipient_email)
  returning id into v_invite_id;

  return v_invite_id;
end;
$function$
"
public,send_event_invite,"p_event_id uuid, p_invitee_email text","CREATE OR REPLACE FUNCTION public.send_event_invite(p_event_id uuid, p_invitee_email text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_invite_id uuid;
  v_invitee_id uuid;
  v_event_title text;
  v_event_date date;
  v_join_code text;
  v_inviter_name text;
  v_has_push_token boolean;
  v_request_id bigint;
  v_email_url text;
begin
  -- Validate inviter is event member
  if not exists (
    select 1 from public.event_members
    where event_id = p_event_id and user_id = auth.uid()
  ) then
    raise exception 'Not authorized to invite to this event';
  end if;

  -- Normalize email
  p_invitee_email := lower(trim(p_invitee_email));

  -- Validate email format (basic)
  if p_invitee_email !~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$' then
    raise exception 'Invalid email format';
  end if;

  -- Check if user is already a member
  if exists (
    select 1 from public.event_members em
    join auth.users u on u.id = em.user_id
    where em.event_id = p_event_id and lower(u.email) = p_invitee_email
  ) then
    raise exception 'User is already a member of this event';
  end if;

  -- Get event details
  select title, event_date, join_code
  into v_event_title, v_event_date, v_join_code
  from public.events
  where id = p_event_id;

  -- Get inviter display name
  select coalesce(display_name, 'Someone') into v_inviter_name
  from public.profiles
  where id = auth.uid();

  -- Check if invitee is a registered user
  select id into v_invitee_id
  from auth.users
  where lower(email) = p_invitee_email;

  -- Create or update invite
  insert into public.event_invites (event_id, inviter_id, invitee_email, invitee_id)
  values (p_event_id, auth.uid(), p_invitee_email, v_invitee_id)
  on conflict (event_id, invitee_email) do update
    set inviter_id = excluded.inviter_id,
        invitee_id = excluded.invitee_id,
        status = 'pending',
        invited_at = now(),
        responded_at = null
  returning id into v_invite_id;

  -- Send email invitation (for both registered and unregistered users)
  -- Note: Update the URL to match your Supabase project
  v_email_url := 'https://bqgakovbbbiudmggduvu.supabase.co/functions/v1/send-invite-email';

  select net.http_post(
    url := v_email_url,
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJxZ2Frb3ZiYmJpdWRtZ2dkdXZ1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTcwNTY1MjEsImV4cCI6MjA3MjYzMjUyMX0.i81E7-w03a1v6BV2FwGpuNRA9tTVWF3nATgJeeO5g1k'
    ),
    body := jsonb_build_object(
      'to', p_invitee_email,
      'inviterName', v_inviter_name,
      'eventName', v_event_title,
      'eventDate', v_event_date,
      'joinCode', v_join_code,
      'eventTimezone', 'UTC'
    )
  ) into v_request_id;

  -- If user is registered and has push tokens, also queue notification
  if v_invitee_id is not null then
    select exists (
      select 1 from public.push_tokens where user_id = v_invitee_id
    ) into v_has_push_token;

    if v_has_push_token then
      insert into public.notification_queue (user_id, title, body, data)
      values (
        v_invitee_id,
        'Event Invitation',
        v_inviter_name || ' invited you to ' || v_event_title,
        jsonb_build_object(
          'type', 'event_invite',
          'invite_id', v_invite_id,
          'event_id', p_event_id
        )
      );
    end if;
  end if;

  return v_invite_id;
end;
$function$
"
public,set_list_created_by,,"CREATE OR REPLACE FUNCTION public.set_list_created_by()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  if new.created_by is null then
    new.created_by := auth.uid();
  end if;
  return new;
end;
$function$
"
public,set_onboarding_done,p_done boolean,"CREATE OR REPLACE FUNCTION public.set_onboarding_done(p_done boolean)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  if auth.uid() is null then
    raise exception 'not_authenticated';
  end if;

  update public.profiles
  set onboarding_done = coalesce(p_done, true),
      onboarding_at   = case when coalesce(p_done, true) then now() else null end
  where id = auth.uid();
end
$function$
"
public,set_plan,"p_plan text, p_months integer DEFAULT 0, p_user uuid DEFAULT auth.uid()","CREATE OR REPLACE FUNCTION public.set_plan(p_plan text, p_months integer DEFAULT 0, p_user uuid DEFAULT auth.uid())
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  if p_plan = 'pro' then
    update public.profiles
       set plan = 'pro',
           pro_until = case when p_months > 0 then now() + (p_months||' months')::interval else null end
     where id = p_user;
  else
    update public.profiles
       set plan = 'free',
           pro_until = null
     where id = p_user;
  end if;
end;
$function$
"
public,set_profile_name,p_name text,"CREATE OR REPLACE FUNCTION public.set_profile_name(p_name text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  insert into public.profiles (id, display_name)
  values (auth.uid(), p_name)
  on conflict (id) do update set display_name = excluded.display_name;
end;
$function$
"
public,test_get_my_claims,,"CREATE OR REPLACE FUNCTION public.test_get_my_claims()
 RETURNS TABLE(claim_id uuid, item_id uuid, purchased boolean, created_at timestamp with time zone, auth_user_id uuid, can_see_claim boolean)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  RETURN QUERY
  SELECT
    c.id as claim_id,
    c.item_id,
    c.purchased,
    c.created_at,
    auth.uid() as auth_user_id,
    (c.claimer_id = auth.uid()) as can_see_claim
  FROM claims c
  WHERE c.claimer_id = auth.uid();
END;
$function$
"
public,test_impersonate,p_user_id uuid,"CREATE OR REPLACE FUNCTION public.test_impersonate(p_user_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
begin
  perform set_config(
    'request.jwt.claims',
    json_build_object('sub', p_user_id::text)::text,
    true
  );
end;
$function$
"
public,tg_set_timestamp,,"CREATE OR REPLACE FUNCTION public.tg_set_timestamp()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
BEGIN
    NEW.updated_at = now();
    RETURN NEW; 
END;
$function$
"
public,trigger_daily_digest,,"CREATE OR REPLACE FUNCTION public.trigger_daily_digest()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  declare
    v_url text;
    v_request_id bigint;
  begin
    v_url :=
  'https://bqgakovbbbiudmggduvu.supabase.co/functions/v1/send-daily-digest';

    -- Call the edge function WITHOUT passing hour - let it use current time
    -- This allows timezone-aware digest scheduling to work properly
    select net.http_post(
      url := v_url,
      headers := '{""Content-Type"": ""application/json"", ""Authorization"": 
  ""Bearer 
  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJxZ
  2Frb3ZiYmJpdWRtZ2dkdXZ1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTcwNTY1MjEsImV4cCI
  6MjA3MjYzMjUyMX0.i81E7-w03a1v6BV2FwGpuNRA9tTVWF3nATgJeeO5g1k""}'::jsonb,
      body := '{}'::jsonb
    ) into v_request_id;
  end;
  $function$
"
public,trigger_push_notifications,,"CREATE OR REPLACE FUNCTION public.trigger_push_notifications()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare
  v_url text;
  v_request_id bigint;
begin
  v_url := 'https://bqgakovbbbiudmggduvu.supabase.co/functions/v1/send-push-notifications';

  select net.http_post(
    url := v_url,
    headers := '{""Content-Type"": ""application/json"", ""Authorization"": ""Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJxZ2Frb3ZiYmJpdWRtZ2dkdXZ1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTcwNTY1MjEsImV4cCI6MjA3MjYzMjUyMX0.i81E7-w03a1v6BV2FwGpuNRA9tTVWF3nATgJeeO5g1k""}'::jsonb
  ) into v_request_id;
end;
$function$
"
public,trigger_refresh_stats_on_claim_delete,,"CREATE OR REPLACE FUNCTION public.trigger_refresh_stats_on_claim_delete()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_event_id uuid;
BEGIN
  -- Get the event_id from the claim's item
  SELECT l.event_id INTO v_event_id
  FROM items i
  JOIN lists l ON l.id = i.list_id
  WHERE i.id = OLD.item_id;

  -- Refresh stats for this user in this event
  IF v_event_id IS NOT NULL THEN
    PERFORM refresh_event_member_stats(v_event_id, OLD.claimer_id);
  END IF;

  RETURN OLD;
END;
$function$
"
public,trigger_refresh_stats_on_item_delete,,"CREATE OR REPLACE FUNCTION public.trigger_refresh_stats_on_item_delete()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_event_id uuid;
  v_claimer_id uuid;
BEGIN
  -- Get event_id from the item's list
  SELECT event_id INTO v_event_id
  FROM lists
  WHERE id = OLD.list_id;

  -- Refresh stats for all users who had claims on this item
  IF v_event_id IS NOT NULL THEN
    FOR v_claimer_id IN
      SELECT DISTINCT claimer_id FROM claims WHERE item_id = OLD.id
    LOOP
      PERFORM refresh_event_member_stats(v_event_id, v_claimer_id);
    END LOOP;
  END IF;

  RETURN OLD;
END;
$function$
"
public,trigger_refresh_stats_on_list_delete,,"CREATE OR REPLACE FUNCTION public.trigger_refresh_stats_on_list_delete()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_claimer_id uuid;
BEGIN
  -- Refresh stats for all users who had claims on items in this list
  FOR v_claimer_id IN
    SELECT DISTINCT c.claimer_id
    FROM claims c
    JOIN items i ON i.id = c.item_id
    WHERE i.list_id = OLD.id
  LOOP
    PERFORM refresh_event_member_stats(OLD.event_id, v_claimer_id);
  END LOOP;

  RETURN OLD;
END;
$function$
"
public,unclaim_item,p_item_id uuid,"CREATE OR REPLACE FUNCTION public.unclaim_item(p_item_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  u uuid := auth.uid();
begin
  if u is null then
    raise exception 'not_authenticated';
  end if;

  delete from public.claims
  where item_id = p_item_id
    and claimer_id = u;
end;
$function$
"
public,unmark_orphaned_lists_on_member_join,,"CREATE OR REPLACE FUNCTION public.unmark_orphaned_lists_on_member_join()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  -- When a new member joins an event, remove any orphaned list markers for that event
  DELETE FROM public.orphaned_lists
  WHERE event_id = NEW.event_id;

  RETURN NEW;
END;
$function$
"
public,update_event_member_stats_on_claim_change,,"CREATE OR REPLACE FUNCTION public.update_event_member_stats_on_claim_change()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_event_id uuid;
  v_claimer_id uuid;
  v_old_claimer_id uuid;
BEGIN
  -- Handle INSERT and UPDATE
  IF TG_OP IN ('INSERT', 'UPDATE') THEN
    -- Get event_id and claimer_id from the new claim
    SELECT l.event_id, NEW.claimer_id
    INTO v_event_id, v_claimer_id
    FROM items i
    JOIN lists l ON l.id = i.list_id
    WHERE i.id = NEW.item_id;

    -- Recalculate stats for this user in this event
    IF v_event_id IS NOT NULL AND v_claimer_id IS NOT NULL THEN
      PERFORM recalculate_event_member_stats(v_event_id, v_claimer_id);
    END IF;
  END IF;

  -- Handle UPDATE where claimer_id changed (claim reassignment)
  IF TG_OP = 'UPDATE' AND OLD.claimer_id IS DISTINCT FROM NEW.claimer_id THEN
    -- Get event_id for old claimer
    SELECT l.event_id
    INTO v_event_id
    FROM items i
    JOIN lists l ON l.id = i.list_id
    WHERE i.id = OLD.item_id;

    -- Recalculate stats for old claimer
    IF v_event_id IS NOT NULL AND OLD.claimer_id IS NOT NULL THEN
      PERFORM recalculate_event_member_stats(v_event_id, OLD.claimer_id);
    END IF;
  END IF;

  -- Handle DELETE
  IF TG_OP = 'DELETE' THEN
    -- Get event_id and claimer_id from the deleted claim
    SELECT l.event_id, OLD.claimer_id
    INTO v_event_id, v_claimer_id
    FROM items i
    JOIN lists l ON l.id = i.list_id
    WHERE i.id = OLD.item_id;

    -- Recalculate stats for this user in this event
    IF v_event_id IS NOT NULL AND v_claimer_id IS NOT NULL THEN
      PERFORM recalculate_event_member_stats(v_event_id, v_claimer_id);
    END IF;
  END IF;

  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  ELSE
    RETURN NEW;
  END IF;
END;
$function$
"
public,update_event_member_stats_on_list_event_change,,"CREATE OR REPLACE FUNCTION public.update_event_member_stats_on_list_event_change()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_user_id uuid;
BEGIN
  -- Only handle UPDATE where event_id changed
  IF TG_OP = 'UPDATE' AND OLD.event_id IS DISTINCT FROM NEW.event_id THEN
    -- Get all users who have claims on items in this list
    FOR v_user_id IN
      SELECT DISTINCT c.claimer_id
      FROM claims c
      JOIN items i ON i.id = c.item_id
      WHERE i.list_id = NEW.id
    LOOP
      -- Recalculate for old event
      PERFORM recalculate_event_member_stats(OLD.event_id, v_user_id);
      -- Recalculate for new event
      PERFORM recalculate_event_member_stats(NEW.event_id, v_user_id);
    END LOOP;
  END IF;

  RETURN NEW;
END;
$function$
"
public,update_event_member_stats_on_recipient_change,,"CREATE OR REPLACE FUNCTION public.update_event_member_stats_on_recipient_change()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_event_id uuid;
  v_affected_users uuid[];
BEGIN
  -- Get event_id from the list
  SELECT l.event_id
  INTO v_event_id
  FROM lists l
  WHERE l.id = COALESCE(NEW.list_id, OLD.list_id);

  IF v_event_id IS NULL THEN
    IF TG_OP = 'DELETE' THEN
      RETURN OLD;
    ELSE
      RETURN NEW;
    END IF;
  END IF;

  -- When a user is added/removed as recipient, their claim stats might change
  -- because we exclude claims on lists where user is recipient

  -- Collect affected user IDs
  v_affected_users := ARRAY[]::uuid[];

  IF TG_OP IN ('INSERT', 'UPDATE') AND NEW.user_id IS NOT NULL THEN
    v_affected_users := array_append(v_affected_users, NEW.user_id);
  END IF;

  IF TG_OP IN ('DELETE', 'UPDATE') AND OLD.user_id IS NOT NULL THEN
    v_affected_users := array_append(v_affected_users, OLD.user_id);
  END IF;

  -- Recalculate stats for each affected user
  FOR i IN 1..array_length(v_affected_users, 1) LOOP
    PERFORM recalculate_event_member_stats(v_event_id, v_affected_users[i]);
  END LOOP;

  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  ELSE
    RETURN NEW;
  END IF;
END;
$function$
"
public,update_invites_on_user_signup,,"CREATE OR REPLACE FUNCTION public.update_invites_on_user_signup()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'auth'
AS $function$
declare
  v_email text;
begin
  -- Find the user's email from auth.users using the ID we do have
  select u.email into v_email
  from auth.users u
  where u.id = NEW.id;

  if v_email is not null and length(v_email) > 0 then
    update public.event_invites
      set invitee_id = NEW.id
    where invitee_id is null
      and status = 'pending'
      and lower(invitee_email) = lower(v_email);
  end if;

  return NEW;
end;
$function$
"
public,validate_email,p_email text,"CREATE OR REPLACE FUNCTION public.validate_email(p_email text)
 RETURNS boolean
 LANGUAGE plpgsql
 IMMUTABLE
 SET search_path TO ''
AS $function$
BEGIN
  RETURN p_email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$';
END;
$function$
"
public,validate_uuid,p_value text,"CREATE OR REPLACE FUNCTION public.validate_uuid(p_value text)
 RETURNS boolean
 LANGUAGE plpgsql
 IMMUTABLE
 SET search_path TO ''
AS $function$
BEGIN
  -- Try to cast to UUID
  PERFORM p_value::uuid;
  RETURN true;
EXCEPTION
  WHEN OTHERS THEN
    RETURN false;
END;
$function$
"
public,whoami,,"CREATE OR REPLACE FUNCTION public.whoami()
 RETURNS jsonb
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  select jsonb_build_object(
    'uid', auth.uid(),
    'role', current_setting('request.jwt.claim.role', true)
  );
$function$
"